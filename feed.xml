<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://www.lnki.me/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.lnki.me/" rel="alternate" type="text/html" /><updated>2021-02-20T21:07:14+08:00</updated><id>https://www.lnki.me/feed.xml</id><title type="html">Lnki’s Home · 网上冲浪日志</title><subtitle>这里是 Lnki 的小站，我在这里分享知识、记录日常。</subtitle><author><name>Lnki</name></author><entry><title type="html">常见协议之 ARP 与 DHCP</title><link href="https://www.lnki.me/2018/09/arp-dhcp/" rel="alternate" type="text/html" title="常见协议之 ARP 与 DHCP" /><published>2018-09-30T00:00:00+08:00</published><updated>2018-09-30T00:00:00+08:00</updated><id>https://www.lnki.me/2018/09/arp-dhcp</id><content type="html" xml:base="https://www.lnki.me/2018/09/arp-dhcp/">&lt;h2 id=&quot;一arp&quot;&gt;一、ARP&lt;/h2&gt;

&lt;p&gt;ARP 即地址解析协议，用于将 IP 地址解析为 MAC 地址，来建立逻辑地址到物理地址的映射。&lt;/p&gt;

&lt;p&gt;发送方将 IP 报文封装为帧时，需要知道接收方的 MAC 地址。如下图所示，发送方先查找本地 ARP 缓存是否存在目的 IP 地址或下一跳的 MAC 地址记录，若没有记录，就会广播 ARP Request 报文，询问接收方的 MAC 地址，接收方具有目的 IP 地址，将会以单播的形式响应，告知自己的 MAC 地址，同时记录发送方的 IP 地址和 MAC 地址。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/arp.webp&quot; alt=&quot;ARP 地址解析过程示意图&quot; /&gt;
  &lt;figcaption&gt;
      ARP 地址解析过程

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;除了解析地址，ARP 还用于探测局域网中IP地址是否存在。对于 IPv4 网络，kernel 会定时向指定 IP 发送单播的 ARP Request 报文，通常是 1 分钟发送 3 个，若所有请求都没有收到 ARP Response 报文，内核判定探测的 IP 地址在网络中已不可达，通过 netlink 向用户空间报告 IP 地址不可达的事件。&lt;/p&gt;

&lt;h2 id=&quot;二dhcp&quot;&gt;二、DHCP&lt;/h2&gt;

&lt;p&gt;IPv4 网络常使用 DHCP 进行 IP 地址分配，DHCP 交换过程分为四步，就像下图这样：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/dhcp.webp&quot; alt=&quot;DHCP 地址申请过程图&quot; /&gt;
  &lt;figcaption&gt;
      DHCP 地址申请过程

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;客户端请求 IP 地址时，在局域网中广播一个 DHCPDISCOVER 报文，源地址为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.0.0.0&lt;/code&gt;，目的地址为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;255.255.255.255&lt;/code&gt;，即 IP 广播地址；&lt;/li&gt;
  &lt;li&gt;DHCP 服务器收到后以广播的方式回复 DHCPOFFER 报文，包含服务器 IP 地址、地址池中可以分配的 IP 地址，以及其他 DHCP 配置信息；&lt;/li&gt;
  &lt;li&gt;网络中可能存在多个 DHCP 服务器，客户端收到第一个 DHCPOFFER 报文后便不再接受其他 DHCPOFFER 报文，广播 DHCPREQUEST 报文，向指定的 DHCP 服务器请求 IP 地址；&lt;/li&gt;
  &lt;li&gt;DHCP 服务器返回 DHCPACK 报文，确认 IP 地址分配，依然是广播的方式，若收到 DHCPREQUEST 报文时被申请的 IP 已被分配，则发送 DHCPDECLINE 报文告知 IP 已不可用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;客户端收到后 DHCPACK 后，IP 地址配置完成，可以进行 IP 通信。客户端可以随时发送 DHCPRELEASE 报文释放 IP 地址，服务端收到后回收 IP 地址。如果客户端请求的 IP 地址不可用，DHCP 服务器会响应 DHCPNAK，客户端会重新开始 DHCP 交换流程。&lt;/p&gt;

&lt;p&gt;通过 DHCP 分配的 IP 地址是有租期的，客户端需要定期发起续租，续租过程分为 renew 和 rebind 两个阶段，客户端维护两个计时器 T1 和 T2，分别对应 renew 和 rebind，计时结束时启动相应阶段的续租流程。下面是 DHCP 续租流程：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/dhcp-renew-rebind.webp&quot; alt=&quot;DHCP 刷新时序图&quot; /&gt;
  &lt;figcaption&gt;
      &lt;a href=&quot;http://www.tcpipguide.com/free/t_DHCPLeaseRenewalandRebindingProcesses-2.htm&quot;&gt;DHCP 刷新过程&lt;/a&gt;

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;T1 结束时，客户端向与 IP 地址配置绑定的 DHCP 服务器单播 DHCPREQUEST 报文，请求获取相同的配置，若该 DHCP 服务器响应 DHCPACK 报文，则续租完成，T1 和 T2 重新计时，否则重新发送 DHCPREQUEST 报文，直到 T2 结束。&lt;/li&gt;
  &lt;li&gt;T2 结束，意味着指定的 DHCP 服务器不可访问，此时客户端广播 DHCPREQUEST 报文，网络中的其他 DHCP 服务器响应 DHCPACK，续租完成，T1、T2 重新计时，否则重复广播 DHCPREQUEST 报文，直至租期结束。&lt;/li&gt;
  &lt;li&gt;如果租期结束，或者客户端收到了 DHCPNAK 报文，则续租失败，客户端发起新的 DHCP 地址申请流程。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Lnki</name></author><category term="技术" /><category term="网络" /><summary type="html">一、ARP</summary></entry><entry><title type="html">Android 中的状态机实现</title><link href="https://www.lnki.me/2018/09/android-state-machine/" rel="alternate" type="text/html" title="Android 中的状态机实现" /><published>2018-09-19T00:00:00+08:00</published><updated>2018-09-19T00:00:00+08:00</updated><id>https://www.lnki.me/2018/09/android-state-machine</id><content type="html" xml:base="https://www.lnki.me/2018/09/android-state-machine/">&lt;p&gt;状态机是一种面向对象的设计模式，用来描述对象在生命周期中的各种状态，以及它们之间的关系。状态机中每种状态只能进行某些特定的操作，且只能切换到某些状态。它的好处是使逻辑与状态机代码分离，提升代码可读性和可维护性。&lt;/p&gt;

&lt;h2 id=&quot;一架构&quot;&gt;一、架构&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateMachine&lt;/code&gt; 实现了 Android 状态机的基本逻辑，只允许 Android 系统内部调用，它的内部结构如图：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/android-statemachine.webp&quot; alt=&quot;Android StateMachine 类图&quot; /&gt;
  &lt;figcaption&gt;
      StateMachine 架构示意

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateMachine&lt;/code&gt; 所实现的状态机是一种分层状态机（Hierarchical State Machine，HSM），分层管理状态和处理消息。HSM 维护一个层次结构，也就是状态树，每一层都有一个或多个状态，这些状态派生自 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateMachine&lt;/code&gt; 收到的消息会被传递至这些状态，派生一种状态需要实现其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processMessage&lt;/code&gt; 方法来完成该状态的消息处理逻辑。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateMachine&lt;/code&gt; 所实现的状态机启动时，会构造一个状态树，固定每种状态及其父状态、子状态的关系，然后将当前状态设置为指定的初始状态，当前状态相当于一个指针，它在这棵状态树上游走。以下面的状态机层次结构为例，设 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mS5&lt;/code&gt; 为初始状态，构造完成时，当前状态的转移路径为从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mS5&lt;/code&gt; 的最远父状态也就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mP0&lt;/code&gt; 开始，依次经过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mP1&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mS1&lt;/code&gt;，直到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mS5&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      mP0
     /   \
    mP1   mS0
   /   \
  mS2   mS1
 /   \     \
mS3   mS4   mS5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;完成启动后，状态机开始处理消息。当状态机收到一个消息时，首先转给当前状态 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mS5&lt;/code&gt;，由其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processMessage&lt;/code&gt; 方法处理。若子状态不能处理，消息将被转给其父状态，以此类推，状态机沿着状态树逐级上溯，直到找到一个可以处理该消息的状态，比如一条只有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mP1&lt;/code&gt; 才能处理的消息，会经过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mS5&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mS1&lt;/code&gt; 再转进 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mP1&lt;/code&gt;。如果追溯到最远父状态 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mP0&lt;/code&gt; 依然不能处理，该消息就会被最后集中处理。&lt;/p&gt;

&lt;p&gt;状态机内部有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handler&lt;/code&gt;，它负责维护消息队列，并完成消息管理和分发，进入状态机的消息可以选择加入这个消息队列的头部或是尾部，每次处理消息 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handler&lt;/code&gt; 就从消息队列头部取出一条消息，分发给相应的状态处理。处理消息时，负责处理消息的状态可以标记要切换到的新状态，待消息处理完后，状态机会自动切换过去。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateMachine&lt;/code&gt; 有两个特殊的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&lt;/code&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HaltingState&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuittingState&lt;/code&gt;，它们出现在状态机退出的过程中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;haltingState&lt;/code&gt; 是停止、即将退出的状态，进入这个状态后，将不能再回到普通状态，此时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handler&lt;/code&gt; 依然在运行，所有的消息由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;haltedProcessMessage&lt;/code&gt; 方法处理；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuitingState&lt;/code&gt; 是退出状态，这个状态结束后，状态机线程结束，完全退出。假设当前状态依然是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mS5&lt;/code&gt;，停止或退出状态机时，沿着状态树先后退出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mS5&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mS1&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mP1&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mP0&lt;/code&gt;，最后如果停止则进入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mHaltingState&lt;/code&gt;，如果退出则进入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mQuittingState&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;二代码解读&quot;&gt;二、代码解读&lt;/h2&gt;

&lt;h3 id=&quot;1-状态机初始化&quot;&gt;1. 状态机初始化&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateMachine&lt;/code&gt; 提供了三个构造方法，三个方法大同小异，构造时如果没有提供 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Looper&lt;/code&gt;，就使用内部线程的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Looper&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StateMachine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mSmThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HandlerThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mSmThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Looper&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;looper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSmThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLooper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;initStateMachine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;looper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateMachine&lt;/code&gt; 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Looper&lt;/code&gt; 所在的线程运行，状态机初始化时使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Looper&lt;/code&gt; 构造一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmHandler&lt;/code&gt;，用于处理状态机的通讯。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initStateMachine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Looper&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;looper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mSmHandler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SmHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;looper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateMachine&lt;/code&gt; 是一种 HSM，需要调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addState&lt;/code&gt; 方法指定它的层级关系，为指定的父状态添加子状态，如果不指定父状态，则创建一个孤立的状态节点。状态关系信息存储于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mStateInfo&lt;/code&gt; 中。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;addStateInternal: E state=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;,parent=&quot;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parentStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;parentStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parentStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Recursively add our parent as it's not been added yet.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;parentStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Validate that we aren't adding the same state in two different hierarchies.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parentStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parentStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parentStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RuntimeException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;state already added&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parentStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parentStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;addStateInternal: X stateInfo: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;构造完成后，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; 方法启动状态机，其内部调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;completeConstruction&lt;/code&gt; 方法，完成状态机构造的动作。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;completeConstruction&lt;/code&gt; 方法首先遍历状态树，并找到树的最大深度，用于确定状态栈的大小，并构造初始的状态栈，所有动作完成后，发送 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SM_INIT_CMD&lt;/code&gt; 消息，报告状态机已构造完成。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;completeConstruction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;completeConstruction: E&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
      * Determine the maximum depth of the state hierarchy
      * so we can allocate the state stacks.
      */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxDepth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;si&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;si&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parentStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxDepth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;maxDepth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;completeConstruction: maxDepth=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxDepth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;mStateStack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxDepth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mTempStateStack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxDepth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;setupInitialStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** Sending SM_INIT_CMD message to invoke enter methods asynchronously */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sendMessageAtFrontOfQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obtainMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;SM_INIT_CMD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSmHandlerObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;completeConstruction: X&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;构造状态栈时，先构造临时状态栈，从初始状态开始，上溯状态树，依次放入临时状态栈中，直到最远父状态，最后再将临时状态栈内容以相反的顺序保存至状态栈中。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setupInitialStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;setupInitialStateStack: E mInitialState=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mInitialState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mInitialState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mTempStateStackCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mTempStateStackCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mTempStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mTempStateStackCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parentStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Empty the StateStack&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mStateStackTopIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;moveTempStateStackToStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;moveTempStateStackToStateStack&lt;/code&gt; 方法将临时状态栈按相反顺序保存到状态栈中。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;moveTempStateStackToStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateStackTopIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mTempStateStackCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;moveTempStackToStateStack: i=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;,j=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mTempStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;mStateStackTopIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;moveTempStackToStateStack: X mStateStackTop=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateStackTopIndex&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;,startingIndex=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;,Top=&quot;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mStateStackTopIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmHandler&lt;/code&gt; 从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Looper&lt;/code&gt; 取得 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SM_INIT_CMD&lt;/code&gt; 消息，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleMessage&lt;/code&gt; 进行处理，内部再调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invokeEnterMethods&lt;/code&gt;，以进入到初始状态。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handleMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mHasQuit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;what&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SM_INIT_CMD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;what&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SM_QUIT_CMD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onPreHandleMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;handleMessage: E msg.what=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;what&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/** Save the current message */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mMsg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/** State that processed the message */&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msgProcessedState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mIsConstructionCompleted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;what&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SM_QUIT_CMD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/** Normal path */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;msgProcessedState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mIsConstructionCompleted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;what&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SM_INIT_CMD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSmHandlerObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/** Initial one time path. */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mIsConstructionCompleted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;invokeEnterMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RuntimeException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;StateMachine.handleMessage: &quot;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;The start method not called, received msg: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;performTransitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msgProcessedState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// We need to check if mSm == null here as we could be quitting.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;handleMessage: X&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;what&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SM_INIT_CMD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;what&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SM_QUIT_CMD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onPostHandleMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invokeEnterMethods&lt;/code&gt; 的参数为一个整数，表示第一个要进入的状态在栈中的索引位置，从该位置开始依次调用每个状态的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enter&lt;/code&gt; 方法，直到到达栈顶。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;invokeEnterMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stateStackEnteringIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stateStackEnteringIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateStackTopIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stateStackEnteringIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateStackTopIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Last enter state for transition&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mTransitionInProgress&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;invokeEnterMethods: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;enter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mTransitionInProgress&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ensure flag set to false if no methods called&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至此，状态机的初始化过程完成。&lt;/p&gt;

&lt;h3 id=&quot;2-消息处理&quot;&gt;2. 消息处理&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateMachine&lt;/code&gt; 收到的消息由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler&lt;/code&gt; 负责管理和分发，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleMessage&lt;/code&gt; 方法内部，收到消息并且判断 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateMachine&lt;/code&gt; 已经启动完成时，就会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processMsg&lt;/code&gt; 方法，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processMsg&lt;/code&gt; 获取状态栈栈顶——即当前状态的信息，然后调用所对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&lt;/code&gt; 对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processMessage&lt;/code&gt; 方法，在状态内完成消息处理逻辑。若当前状态无法处理该消息，或是处理完后需要父状态继续处理，则继续调用父状态 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&lt;/code&gt; 对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processMessage&lt;/code&gt; 方法，直到消息处理完成，若所有父状态都不能处理，则调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unHandledMessage&lt;/code&gt;，尝试最后一次消息处理。该方法返回最后处理消息的状态，抑或是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;processMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mStateStackTopIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;processMsg: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isQuit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transitionTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mQuittingState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;processMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/**
              * Not processed
              */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parentStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;cm&quot;&gt;/**
                  * No parents left so it's not handled
                  */&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unhandledMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;processMsg: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-状态切换&quot;&gt;3. 状态切换&lt;/h3&gt;

&lt;p&gt;每个状态在消息处理时，可以选择切换到指定状态，这个过程通过调用状态机的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transitionTo&lt;/code&gt; 方法触发。状态切换完成后，下一个消息将由新的状态处理。可以看到实际上是调用的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler.transitionTo&lt;/code&gt; 方法。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transitionTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IState&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mSmHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;transitionTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler.transitionTo&lt;/code&gt; 仅标记状态切换的目标状态，实际上不会执行切换操作，这是为了在状态切换前，完成包括当前状态和一系列父状态的消息处理逻辑，待消息处理完成并返回到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler.handleMessage&lt;/code&gt; 方法后再通过调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;performTransitions&lt;/code&gt; 方法执行切换。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/** @see StateMachine#transitionTo(IState) */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transitionTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IState&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mTransitionInProgress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wtf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;transitionTo called while transition already in progress to &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;mDestState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, new target state=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mDestState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transitionTo: destState=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mDestState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;performTransitions&lt;/code&gt; 方法负责执行状态的切换流程。首先调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setupTempStateStackWithStatesToEnter&lt;/code&gt; 方法来获得当前状态和目的状态的公共父状态，然后调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invokeExitMethods&lt;/code&gt; 方法从当前状态沿状态栈逐级退出到公共父状态，再调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invokeEnterMethods&lt;/code&gt; 方法从公共父状态进入到目的状态，最后调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;moveDeferredMessageAtFrontOfQueue&lt;/code&gt; 方法将延时消息列表的消息导入到消息队列头部。若在此过程中，目的状态发生改变，则再次执行，直到最终的状态与目的状态一致。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;performTransitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msgProcessedState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/**
      * If transitionTo has been called, exit and then enter
      * the appropriate states. We loop on this to allow
      * enter and exit methods to use transitionTo.
      */&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orgState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mStateStackTopIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
      * Record whether message needs to be logged before we transition and
      * and we won't log special messages SM_INIT_CMD or SM_QUIT_CMD which
      * always set msg.obj to the handler.
      */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recordLogMsg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;recordLogRec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSmHandlerObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mLogRecords&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;logOnlyTransitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/** Record only if there is a transition */&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDestState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mLogRecords&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLogRecString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msgProcessedState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;orgState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mDestState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recordLogMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/** Record message */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mLogRecords&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLogRecString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msgProcessedState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orgState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;mDestState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mDestState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/**
          * Process the transitions including transitions in the enter/exit methods
          */&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;handleMessage: new destination call exit/enter&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;cm&quot;&gt;/**
              * Determine the states to exit and enter and return the
              * common ancestor state of the enter/exit states. Then
              * invoke the exit methods then the enter methods.
              */&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commonStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setupTempStateStackWithStatesToEnter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// flag is cleared in invokeEnterMethods before entering the target state&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mTransitionInProgress&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;invokeExitMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commonStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stateStackEnteringIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moveTempStateStackToStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;invokeEnterMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stateStackEnteringIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;cm&quot;&gt;/**
              * Since we have transitioned to a new state we need to have
              * any deferred messages moved to the front of the message queue
              * so they will be processed before any other messages in the
              * message queue.
              */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;moveDeferredMessageAtFrontOfQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mDestState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// A new mDestState so continue looping&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mDestState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// No change in mDestState so we're done&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mDestState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
      * After processing all transitions check and
      * see if the last transition was to quit or halt.
      */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mQuittingState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/**
              * Call onQuitting to let subclasses cleanup.
              */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onQuitting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cleanupAfterQuitting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mHaltingState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/**
              * Call onHalting() if we've transitioned to the halting
              * state. All subsequent messages will be processed in
              * in the halting state which invokes haltedProcessMessage(msg);
              */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onHalting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setupTempStateStackWithStatesToEnter&lt;/code&gt; 方法构造一个临时状态栈，其中保存状态树中目标状态到公共父状态的依赖路径，并返回栈顶的内容，即当前状态和目的状态的公共父状态，如果没有公共父状态，则返回空。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setupTempStateStackWithStatesToEnter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/**
      * Search up the parent list of the destination state for an active
      * state. Use a do while() loop as the destState must always be entered
      * even if it is active. This can happen if we are exiting/entering
      * the current state.
      */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mTempStateStackCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;StateInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;destState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mTempStateStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mTempStateStackCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parentStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;setupTempStateStackWithStatesToEnter: X mTempStateStackCount=&quot;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mTempStateStackCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;,curStateInfo: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4-消息传递&quot;&gt;4. 消息传递&lt;/h3&gt;

&lt;p&gt;向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateMachine&lt;/code&gt; 传递消息时，最常用的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sendMessage&lt;/code&gt; 方法，有多个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sendMessage&lt;/code&gt; 重载，但都大同小异，内部调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sendMessage&lt;/code&gt; 方法。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sendMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// mSmHandler can be null if the state machine has quit.&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;SmHandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSmHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;smh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;smh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sendMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此外，发送消息时还可以调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deferMessage&lt;/code&gt; 方法，该方法传递的消息将等待当前状态被切换后再处理，同样地，内部调用的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deferMessage&lt;/code&gt; 方法。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deferMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mSmHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;deferMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deferMessage&lt;/code&gt; 方法将消息添加到一个列表中。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deferMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;deferMessage: msg=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;what&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* Copy the &quot;msg&quot; to &quot;newMsg&quot; as &quot;msg&quot; will be recycled */&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newMsg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obtainMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;newMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;copyFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;mDeferredMessages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在状态切换完成后，会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;moveDeferredMessageAtFontOfQueue&lt;/code&gt; 方法完成消息列表更新，从列表最后的消息开始，依次放入消息队列的头部。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;moveDeferredMessageAtFrontOfQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/**
      * The oldest messages on the deferred list must be at
      * the front of the queue so start at the back, which
      * as the most resent message and end with the oldest
      * messages at the front of the queue.
      */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mDeferredMessages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curMsg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mDeferredMessages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;moveDeferredMessageAtFrontOfQueue; what=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;what&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sendMessageAtFrontOfQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mDeferredMessages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5-状态机退出&quot;&gt;5. 状态机退出&lt;/h3&gt;

&lt;p&gt;状态机退出流程通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quit&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quitNow&lt;/code&gt; 方法触发。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quit&lt;/code&gt; 内部调用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quit&lt;/code&gt; 方法。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;quit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// mSmHandler can be null if the state machine is already stopped.&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;SmHandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSmHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;smh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;smh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;quit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler.quit&lt;/code&gt; 方法发送一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SM_QUIT_CMD&lt;/code&gt; 消息，告知退出，如&lt;a href=&quot;#2-消息处理&quot;&gt;前文&lt;/a&gt;所述，该消息在处理时被传入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processMsg&lt;/code&gt;，直接标记切换的目标状态为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuittingState&lt;/code&gt;。该状态不处理任何消息，其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processMessage&lt;/code&gt; 只会返回未处理。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;performTransitions&lt;/code&gt; 执行到退出状态的切换后，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cleanupAfterQuitting&lt;/code&gt; 停止状态机线程并清空状态机信息。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cleanupAfterQuitting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mSmThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// If we made the thread then quit looper which stops the thread.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;getLooper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;quit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mSmThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mSmHandler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mMsg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mLogRecords&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mStateStack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mTempStateStack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mStateInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mInitialState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mDestState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mDeferredMessages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mHasQuit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quitNow&lt;/code&gt; 方法与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quit&lt;/code&gt; 方法基本一致，只是将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SM_QUIT_CMD&lt;/code&gt; 消息放置在消息队列头部，这样状态机将不等待消息队列处理完成便立即退出。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;quitNow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mDbg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;quitNow:&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sendMessageAtFrontOfQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obtainMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;SM_QUIT_CMD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mSmHandlerObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此外还有停止状态 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HaltingState&lt;/code&gt;，可通过调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transitionToHaltingState&lt;/code&gt; 切换过去，该状态只是停止普通状态下的消息处理，不会停止状态机线程或清空状态机信息，消息仍可以由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;haltedProcessMessage&lt;/code&gt; 方法处理。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transitionToHaltingState&lt;/code&gt; 方法实际调用的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler.transitionTo&lt;/code&gt; 方法，传入的参数为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mSmHandler.mHaltingState&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transitionToHaltingState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mSmHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;transitionTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mSmHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mHaltingState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Lnki</name></author><category term="技术" /><category term="Android" /><summary type="html">状态机是一种面向对象的设计模式，用来描述对象在生命周期中的各种状态，以及它们之间的关系。状态机中每种状态只能进行某些特定的操作，且只能切换到某些状态。它的好处是使逻辑与状态机代码分离，提升代码可读性和可维护性。</summary></entry><entry><title type="html">wpa_supplicant 连接实验</title><link href="https://www.lnki.me/2018/09/wpa-supplicant/" rel="alternate" type="text/html" title="wpa_supplicant 连接实验" /><published>2018-09-17T00:00:00+08:00</published><updated>2018-09-17T00:00:00+08:00</updated><id>https://www.lnki.me/2018/09/wpa-supplicant</id><content type="html" xml:base="https://www.lnki.me/2018/09/wpa-supplicant/">&lt;p class=&quot;notice&quot;&gt;此次实验是在 Android 设备中进行的，这里做个记录。&lt;/p&gt;

&lt;p&gt;首先在 Android 设置中关闭 WLAN 以及 WLAN 扫描，然后用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lsmod&lt;/code&gt; 查看 WLAN 驱动状态，如果没有，就用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insmod&lt;/code&gt; 安装，驱动路径为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/vendor/lib/modules/qca_cld3_wlan.ko&lt;/code&gt;。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/lsmod_wlan.webp&quot; alt=&quot;lsmod 结果图&quot; /&gt;
  &lt;figcaption&gt;
      lsmod 查看 wlan 驱动

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;启动并在后台运行 wpa_supplicant 服务端，命令如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/vendor/bin/hw/wpa_supplicant -i wlan0 -D nl80211 -c /vendor/etc/wifi/wpa_supplicant.conf -I /vendor/etc/wifi/wpa_supplicant_overlay.conf -O /data/vendor/wifi/wpa/sockets
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/start-wpa_supplicant.webp&quot; alt=&quot;wpa_supplicant 运行图&quot; /&gt;
  &lt;figcaption&gt;
      运行 wpa_supplicant 服务

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;在新终端中打开 wpa_cli（wpa_supplicant 客户端）并连接 wpa_supplicant 服务，命令如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wpa_cli -i wlan0 -p /data/vendor/wifi/wpa/sockets/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/start-wpa_cli.webp&quot; alt=&quot;wpa_cli 运行图&quot; /&gt;
  &lt;figcaption&gt;
      运行 wpa_cli 并连接 wpa_supplicant 服务

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scan&lt;/code&gt; 命令发起 WLAN 扫描：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
    &lt;a href=&quot;&quot; title=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/trigger-scan.webp&quot; alt=&quot;wpa_cli 扫描图&quot; /&gt;
  
    &lt;/a&gt;
  &lt;figcaption&gt;
      启动 WLAN 扫描

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scan_result&lt;/code&gt;命令查看扫描结果：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/get-scan-results.webp&quot; alt=&quot;wpa_cli 扫描结果图&quot; /&gt;
  &lt;figcaption&gt;
      查看扫描结果

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;这里要连接 WLAN 的 SSID 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vivo NEX S&lt;/code&gt;。先使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_network&lt;/code&gt; 添加一个网络：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/add-network.webp&quot; alt=&quot;wpa_cli 添加网络图&quot; /&gt;
  &lt;figcaption&gt;
      添加一个网络

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;配置网络 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;，设置 SSID、密码和安全策略，命令如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set_network 0 ssid &quot;vivo NEX S&quot;
set_network 0 psk &quot;12345678&quot;
set_network 0 key_mgmt WPA-PSK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/set-network.webp&quot; alt=&quot;wpa_cli 配置网络图&quot; /&gt;
  &lt;figcaption&gt;
      设置网络参数

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;启用网络 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;，wpa_cli 会自动连接可用网络，命令如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enable_network 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/connect-network.webp&quot; alt=&quot;wpa_cli 连接网络&quot; /&gt;
  &lt;figcaption&gt;
      启用和连接网络

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;在新的终端中使用 dhcpcd 获取 IP 地址，直接运行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dhcpcd&lt;/code&gt; 命令：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/dhcpcd-get-ip.webp&quot; alt=&quot;dhcpcd 配置 IP 地址图&quot; /&gt;
  &lt;figcaption&gt;
      通过 DHCP 配置 IP 地址

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;用 ping 来测试网络，命令如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ping 192.168.43.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/ping-test-network.webp&quot; alt=&quot;PING 测试网络图&quot; /&gt;
  &lt;figcaption&gt;
      测试网络连通性

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;至此，wpa_supplicant 连接过程结束，成功连接 WLAN 并可以正常通信。&lt;/p&gt;</content><author><name>Lnki</name></author><category term="技术" /><category term="杂记" /><category term="wpa_supplicant" /><category term="WLAN" /><category term="Android" /><summary type="html">此次实验是在 Android 设备中进行的，这里做个记录。</summary></entry><entry><title type="html">WLAN 中的安全机制概述</title><link href="https://www.lnki.me/2018/09/wlan-sec-overview/" rel="alternate" type="text/html" title="WLAN 中的安全机制概述" /><published>2018-09-15T00:00:00+08:00</published><updated>2018-09-15T00:00:00+08:00</updated><id>https://www.lnki.me/2018/09/wlan-sec-overview</id><content type="html" xml:base="https://www.lnki.me/2018/09/wlan-sec-overview/">&lt;p&gt;WLAN 物理层的传输方式都是无线电广播，由于物理媒介的开放性，避免窃听自然是 WLAN 要提供的一项基本功能。说到 WLAN 安全，我们会想到 802.11i、802.1X、WEP、WPA、EAP、WAPI 等一堆名词，本文介绍它们的概念和作用，并梳理它们的关系。&lt;/p&gt;

&lt;h2 id=&quot;一安全标准&quot;&gt;一、安全标准&lt;/h2&gt;

&lt;p&gt;WLAN 的安全功能最早由 WEP 提供，WEP 在初版 802.11 标准中就已经引入，其被发现存在漏洞后，IEEE 推出了 802.11i，旨在增强 WLAN 安全性，这也是现行的 WLAN 安全标准，WPA 是其子集的技术实现，由 Wi-Fi 联盟推出，除了引进新技术，该标准也对 WEP 进行了改进。&lt;/p&gt;

&lt;h3 id=&quot;1-ieee-80211i-架构&quot;&gt;1. IEEE 802.11i 架构&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211i-arch.webp&quot; alt=&quot;IEEE 802.11i 架构图&quot; /&gt;
  &lt;figcaption&gt;
      IEEE 802.11i 架构

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;图中可以看出，802.11i 主要分为加密、密钥管理、身份认证三个部分。加密和密钥管理机制工作在 MAC 层，WEP、TKIP、CCMP 负责数据加密，密钥管理机制就是进行密钥派生，它根据 PMK 生成 PTK、GTK 等一系列密钥供加密协议使用；身份认证机制工作在 LLC 层及以上范围，802.1X 负责身份认证，只有通过认证的端口才能传输数据，此外还会向密钥管理机制提供密钥。&lt;/p&gt;

&lt;h3 id=&quot;2-工作机制&quot;&gt;2. 工作机制&lt;/h3&gt;

&lt;p&gt;当一台 STA 加入一个支持 802.11i 的 WLAN 时，802.11i 的工作流程总体分为四个阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;参数通报协商阶段：STA 从 AP 广播的 Beacon 中了解 WLAN 的安全配置，然后进行链路认证与关联，完成 WLAN 连接的建立，期间若双方支持的认证和加密方法不兼容，则会连接失败。&lt;/li&gt;
  &lt;li&gt;身份认证阶段：STA 连接后要进行身份认证，过程中会产生密钥，它可以由认证服务器生成，也可以由预先配置的口令生成。&lt;/li&gt;
  &lt;li&gt;密钥协商阶段：协商和配置 STA 与 AP 之间传送数据所需的通信密钥，由前一阶段产生的密钥派生而来。&lt;/li&gt;
  &lt;li&gt;通信阶段：使用通信密钥，经过指定的加密协议加密数据后传送。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-引入的-8021x-内容&quot;&gt;3. 引入的 802.1X 内容&lt;/h3&gt;

&lt;p&gt;802.11i 引入了一些来自 802.1X 的组件，主要用于 WLAN 安全中的身份认证与密钥管理部分。这些组件包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非受控端口（Uncontrolled Port）：未认证的端口，只允许 802.1X 的消息通过；&lt;/li&gt;
  &lt;li&gt;受控端口（Controlled Port）：允许通过或屏蔽其他的所有数据消息；&lt;/li&gt;
  &lt;li&gt;认证者（Authenticator）、申请者（Supplicant）：与远程设备进行身份认证与密钥管理交互的本地设备；&lt;/li&gt;
  &lt;li&gt;认证服务器（Authentication Server，AS）：集中管理身份认证和访问控制的设备。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二身份认证&quot;&gt;二、身份认证&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;

&lt;p&gt;WLAN 中的身份认证主要分两大类：链路认证和接入认证，它们主要区别在于产生作用的时机，前者发生在关联建立之前，后者则是在关联建立之后。由于 WLAN 中的关联就像是以太网中连接网线的动作，那么可以这么理解，链路认证控制的是物理链路的使用权，认证通过的设备才可以连接“网线”，而接入认证控制的是局域网的访问权，接入网络的设备必须通过认证才能正常访问其他设备。&lt;/p&gt;

&lt;h3 id=&quot;1-链路认证&quot;&gt;1. 链路认证&lt;/h3&gt;

&lt;p&gt;链路认证是一种很弱的认证方式，不能提供足够的安全性，它不传递或验证任何加密密钥，也不进行双向的身份认证。&lt;/p&gt;

&lt;h4 id=&quot;ⅰ-开放系统认证&quot;&gt;Ⅰ· 开放系统认证&lt;/h4&gt;

&lt;p&gt;开放系统认证（Open System Authentication，OSA）就是不认证，只是简单地进行一次 Authentication Request/Response 交换，任何 STA 都可以认证成功。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/wlan-auth-open.webp&quot; alt=&quot;开放系统认证握手过程图&quot; /&gt;
  &lt;figcaption&gt;
      开放系统认证过程

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;h4 id=&quot;ⅱ-共享密钥认证&quot;&gt;Ⅱ· 共享密钥认证&lt;/h4&gt;

&lt;p&gt;共享密钥认证（Shared Key Authentication，SKA）使用 WEP，STA 和 AP 预先配置相同的共享密钥，这套机制下只要密钥配置一致即认证成功。认证过程如下图：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/wlan-auth-wep.webp&quot; alt=&quot;共享密钥认证握手过程图&quot; /&gt;
  &lt;figcaption&gt;
      共享密钥认证过程

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;STA 向 AP 发送 Authentication Request；&lt;/li&gt;
  &lt;li&gt;AP 回复携带有明文质询文本的 Authentication Response；&lt;/li&gt;
  &lt;li&gt;STA 发送经 WEP 处理的 Authentication Response 帧，携带密文质询文本；&lt;/li&gt;
  &lt;li&gt;AP 收到后，对密文予以解密，验证 WEP 的完整性，若通过完整性校验，AP 就会响应一个携带认证成功的状态码的 Authentication Response。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-接入认证&quot;&gt;2. 接入认证&lt;/h3&gt;

&lt;p&gt;接入认证基于 802.1X，相比于链路认证，它可以提供更可靠的安全性。&lt;/p&gt;

&lt;p&gt;IEEE 802.1X 基础是 EAP，在认证通过前，只允许 EAPoL（EAP over LAN）帧通过相连的端口，其定义了 3 种角色，分别为申请者 (Supplicant)、认证者 (Authenticator) 以及认证服务器（例如 RADIUS），如下图：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/8021x-roles.webp&quot; alt=&quot;IEEE 802.1X 角色示意图&quot; /&gt;
  &lt;figcaption&gt;
      IEEE 802.1X 中的角色

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;申请者是寻求访问网络资源的设备，认证者扮演交换机的角色，负责链路层的认证交换过程，并负责分配密钥和端口的管理，认证服务器执行身份认证逻辑，有多种认证方法可选。申请者和认证者之间采用 EAPoL 帧，在第二层通信，认证者和认证服务器之间采用 IP 封包，在第三层通信。在 WLAN 中，申请者是要加入网络的 STA，认证者是所关联的 AP，认证服务器位于骨干网络中。&lt;/p&gt;

&lt;p&gt;在 802.11 网络中，典型的 802.1X 认证成功的交互过程如下：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/8021x-procedure.webp&quot; alt=&quot;802.1X 交换过程图&quot; /&gt;
  &lt;figcaption&gt;
      802.11 网络中的 802.1X 交换

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;STA 先关联至 AP；&lt;/li&gt;
  &lt;li&gt;然后 STA 发起 802.1X 交换，首先发送 EAPoL-Start；&lt;/li&gt;
  &lt;li&gt;AP 回复身份认证请求；&lt;/li&gt;
  &lt;li&gt;STA 响应身份标识；&lt;/li&gt;
  &lt;li&gt;AP 告知 STA 要使用的身份认证方法，数据字段中包含质询信息；&lt;/li&gt;
  &lt;li&gt;STA 按照指定的认证方法处理质询信息并回应，取决于具体的认证方法，以上两步可能会进行多轮，直到认证成功；&lt;/li&gt;
  &lt;li&gt;成功后 AP 回复认证成功；&lt;/li&gt;
  &lt;li&gt;接着 AP 再与 STA 协商密钥，至此认证完成，待密钥协商完成 STA 便可以访问网络了；&lt;/li&gt;
  &lt;li&gt;当 STA 不再需要访问网络时，发送 EAPoL-Logoff，撤销授权。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三安全协议&quot;&gt;三、安全协议&lt;/h2&gt;

&lt;h3 id=&quot;1-tkip&quot;&gt;1. TKIP&lt;/h3&gt;

&lt;p&gt;TKIP（Temporal Key Integrity Protocol）即临时密钥完整性协议，是 WEP 的改进版，为了兼容算力较弱的旧系统，TKIP 提供的保护依然较弱，但去除了 WEP 的漏洞，这种保护至少是完整的。&lt;/p&gt;

&lt;p&gt;考虑到兼容，TKIP 的封装过程与 WEP 有些类似，格式如下图：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211i-tkip-encap.webp&quot; alt=&quot;TKIP 封装格式图&quot; /&gt;
  &lt;figcaption&gt;
      TKIP 封装格式

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;TKIP 标头在 MAC 标头之后，IV / Key ID（初始向量 / 密钥 ID）长度 4 字节，保留自 WEP，但有不同含义，最前面的 3 字节记录了部分的 TKIP 序列号和目前使用的密钥编号，虽然 TKIP 支持多组密钥，但只有 Key ID 0 才会被分配使用，EIV（Extended IV，扩展初始向量）则是用来记录 TKIP 序列号的其余部分，这里的序列号是为了防止重放攻击，接下来 TKIP 在有效载荷后加上 MIC（消息完整性校验）码，最后 WEP 会加入其自身的 ICV（完整性校验值），以尽量维持 WEP 格式不变。&lt;/p&gt;

&lt;h3 id=&quot;2-ccmp&quot;&gt;2. CCMP&lt;/h3&gt;

&lt;p&gt;CCMP（Counter Mode with CBC-MAC Protocol）即计数器模式及密码块链消息认证码协议，是 802.11i 引入的全新设计的数据保护协议，它满足了 802.11i 中的所有安全指标，使用 AES 块加密算法，规避了 WEP 所使用的 RC4 流加密的安全隐患。&lt;/p&gt;

&lt;p&gt;CCMP 的封装过程相当直接，格式如下图：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211i-ccmp-encap.webp&quot; alt=&quot;CCMP 封装格式图&quot; /&gt;
  &lt;figcaption&gt;
      CCMP 封装格式

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;CCMP 标头长度为 8 字节，在 MAC 标头之后，记录了 6 字节长的 PN（Packet Number，封包编号），PN 值随每次传输逐渐累加，用于防止重放攻击，封装时 PN 被从第 2、3 字节拆开来，中间填入 13 bit 值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 的保留位、1 bit 值恒为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 的 EIV 和 2 bit 的 Key ID，最后，在负载数据之后加上 8 字节的 MIC。&lt;/p&gt;

&lt;h3 id=&quot;3-协议比较&quot;&gt;3. 协议比较&lt;sup id=&quot;fnref:1:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;

&lt;div class=&quot;table-wrapper&quot;&gt;
  &lt;table&gt;&lt;caption&gt;
        IEEE 802.11i 数据保护协议比较

    &lt;/caption&gt;

  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;安全协议&lt;/th&gt;
      &lt;th&gt;加密算法&lt;/th&gt;
      &lt;th&gt;密钥长度&lt;/th&gt;
      &lt;th&gt;完整性校验 |&lt;/th&gt;
      &lt;th&gt;密钥管理&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;^^&lt;/th&gt;
      &lt;th&gt;^^&lt;/th&gt;
      &lt;th&gt;^^&lt;/th&gt;
      &lt;th&gt;数据&lt;/th&gt;
      &lt;th&gt;标头&lt;/th&gt;
      &lt;th&gt;^^&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;WEP&lt;/td&gt;
      &lt;td&gt;RC4&lt;/td&gt;
      &lt;td&gt;40 或 104 bit&lt;/td&gt;
      &lt;td&gt;CRC-32&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TKIP&lt;/td&gt;
      &lt;td&gt;RC4&lt;/td&gt;
      &lt;td&gt;128 bit 加密&lt;br /&gt;64 bit 防伪&lt;/td&gt;
      &lt;td&gt;Michael&lt;/td&gt;
      &lt;td&gt;Michael&lt;/td&gt;
      &lt;td&gt;802.11i 四次握手&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CCMP&lt;/td&gt;
      &lt;td&gt;AES&lt;/td&gt;
      &lt;td&gt;128 bit&lt;/td&gt;
      &lt;td&gt;CCM&lt;/td&gt;
      &lt;td&gt;CCM&lt;/td&gt;
      &lt;td&gt;802.11i 四次握手&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;/div&gt;

&lt;h2 id=&quot;四密钥管理&quot;&gt;四、密钥管理&lt;/h2&gt;

&lt;h3 id=&quot;1-密钥组成&quot;&gt;1. 密钥组成&lt;/h3&gt;

&lt;p&gt;802.11i 规定链路层加密协议使用两种密钥：成对密钥（Pairwise Key）、组密钥（Group Key），前者用来保护 STA 与 AP 之间往来的单播数据，后者用来保护 AP 与所关联的 STA 之间的广播或组播数据。TKIP 和 CCMP 均使用单一主密钥来产生操作过程中所需的其他密钥，802.11i 引入了密钥分级机制，其目的之一是为了保护这些派生密钥的传送。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211i-pairwise-key.webp&quot; alt=&quot;成对密钥层次结构图&quot; /&gt;
  &lt;figcaption&gt;
      成对密钥层次结构

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;在成对密钥体系中，主密钥称为成对主密钥（PMK），长度为 256 bit。临时密钥通过伪随机函数展开 PMK 来获得，这里展开的临时密钥被称为成对临时密钥（PTK）。TKIP 和 CCMP 均使用 EAPoL-Key 来保护传送的帧，它包含两个 128 bit 的密钥，一个是 EAPoL 密钥确认密钥（EAPoL Key Confirmation Key, KCK），用于验证密钥生成消息的完整性，一种是 EAPoL 密钥加密密钥（EAPOL Key Encryption Key, KEK），用来加密密钥生成消息，KCK 和 KEK 均派生自 PTK。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211i-group-key.webp&quot; alt=&quot;组密钥层次结构图&quot; /&gt;
  &lt;figcaption&gt;
      组密钥层次结构

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;在组密钥体系中，认证者持有组主密钥（GMK），GMK 是临时密钥的基础，长度为 128 bit，生成的临时密钥称为组临时密钥（GTK），这里不会产生 KCK 和 KEK，因为广播和组播不会发生密钥交换的过程。&lt;/p&gt;

&lt;h3 id=&quot;2-密钥来源与分配&quot;&gt;2. 密钥来源与分配&lt;/h3&gt;

&lt;p&gt;802.11i 密钥交换时，成对密钥分别通过各自的握手流程加以更新，如下图所示：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211i-key-handshake.webp&quot; alt=&quot;密钥交换流程图&quot; /&gt;
  &lt;figcaption&gt;
      成对密钥交换与组密钥交换的握手流程

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;成对密钥通过四次握手分配，密钥更新前，申请者与认证者均持有一个共享的 PMK：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;认证者将 nonce 传给申请者，这里的 nonce 是用于防范重放攻击的随机值，同时申请者生成一个 nonce，与认证者发送的 nonce、双方的 MAC 地址一并用于 PMK 的展开，生成完整的密钥层次结构；&lt;/li&gt;
  &lt;li&gt;申请者向认证者发送自己的 nonce 以及初次与网络关联时所获取的安全参数，这条消息使用 KCK 计算的校验值来验证完整性，认证者同样使用双方的 nonce 和 MAC 地址将 PMK 展开为完整的密钥层次结构；&lt;/li&gt;
  &lt;li&gt;双方已经准备好密钥，但需要进一步确认，认证者发送新生成的成对密钥的序列号，以及新生成的 GTK，以便后续更新组密钥，消息使用 KEK 加密，使用 KCK 验证完整性；&lt;/li&gt;
  &lt;li&gt;申请者向认证者发送一个确认消息，告知已收到密钥，可以开始使用新密钥，该消息使用 KCK 验证完整性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;组密钥交换比成对密钥简单，只有两步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第一步认证者使用 KEK 加密发送 GTK，消息使用 KCK 校验；&lt;/li&gt;
  &lt;li&gt;第二部申请者发送确认消息，开始使用新的 GTK，此消息同样使用 KCK 校验。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五一些安全相关的特性&quot;&gt;五、一些安全相关的特性&lt;/h2&gt;

&lt;h3 id=&quot;1-预先身份认证&quot;&gt;1. 预先身份认证&lt;/h3&gt;

&lt;p&gt;预先身份认证（Preauthentication）用来加速关联转移，所谓关联转移就是 Wi-Fi 中的漫游，802.11 将认证过程和关联操作加以拆解，使它们可以独立进行，预先身份认证允许已连接到 WLAN 的 STA 在同一 ESS 内切换 BSS 时，不用重复进行身份认证，而是直接与新 AP 建立关联，以此实现关联转移的加速。&lt;/p&gt;

&lt;h4 id=&quot;ⅰ-80211-预先身份认证&quot;&gt;Ⅰ· 802.11 预先身份认证&lt;/h4&gt;

&lt;p&gt;802.11 并未要求链路认证之后必须立即进行关联操作。STA 可以同时和多个 AP 进行链路认证，然后和其中一个 AP 建立关联，在切换时，STA 先和 AP 断开关联，然后和新的 AP 进行关联，建立关联后即可进行数据传输。&lt;/p&gt;

&lt;h4 id=&quot;ⅱ-80211i-预先身份认证与密钥缓存&quot;&gt;Ⅱ· 802.11i 预先身份认证与密钥缓存&lt;/h4&gt;

&lt;p&gt;由于 802.11i 的身份认证基于 802.1X，而 802.1X 认证过程又需要来回传递多个帧，比较费时。预先身份认证让 STA 在与新的 AP 建立关联之前事先建立一个安全配置，实现关联转移的加速。WPA 则明确排除了预先身份认证的使用。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211i-eap-pre-auth.webp&quot; alt=&quot;802.11i 预先身份认证示意图&quot; /&gt;
  &lt;figcaption&gt;
      802.11i 预先身份认证

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;上图中，STA 通过与 AP1 关联加入 WLAN，在 STA 切换到 AP2 之前，进行预先身份认证：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;STA 经由 AP1 与 AP2 进行 802.1X 认证，完成后 STA 与 AP2 生成相应的的密钥并缓存；&lt;/li&gt;
  &lt;li&gt;待 STA 出发关联切换，关联就会从 AP1 转移到 AP2；&lt;/li&gt;
  &lt;li&gt;STA 向 AP2 提供事先准备的缓存密钥，告知已通过身份认证；&lt;/li&gt;
  &lt;li&gt;AP2 找到匹配的密钥，就开始密钥交换流程，密钥配置完成后，便可以传输数据了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;预先身份认证实际上仍是完整的 802.1X 认证过程，因为 STA 只能和一个 AP 建立关联，STA 和 AP2 之间的帧都要经过 AP1，在从 STA 发往 AP2 的帧中，源地址为 STA，接收端地址为 AP1，目的地址为 AP2，AP1 收到帧后经分布式系统转发至 AP2。&lt;/p&gt;

&lt;h3 id=&quot;2-帧等级与身份认证状态&quot;&gt;2. 帧等级与身份认证状态&lt;sup id=&quot;fnref:2:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;

&lt;p&gt;在 802.11 网络中，有三种身份认证状态，这里的状态是指链路认证状态，每种状态能传送的帧类型不同，这些帧被划分为三个等级，对应于三种身份认证状态的权限等级。身份认证状态中状态 1 为初始状态，即未认证且未关联的，状态 2 为已认证但尚未关联，状态 3 为已认证且已关联，转换关系如下图所示：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-frame-class.webp&quot; alt=&quot;802.11 整体状态图&quot; /&gt;
  &lt;figcaption&gt;
      802.11 身份认证状态及帧等级

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;第 3 级帧包括 PS-Poll、Deauthentication 和除了 ToDS 与 FromDS 都置为 0 的全部数据帧，这些帧只有在状态 3 下才能传送；&lt;/li&gt;
  &lt;li&gt;第 2 级帧只有 5 种管理帧，包括 Association Request / Response、Reassociation Request / Response 和 Disassociation，这些帧只能在状态 2 和状态 3 下传送；&lt;/li&gt;
  &lt;li&gt;第 1 级帧是除了第 2、3 级之外的所有帧，在任何状态下都可传送。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Deauthentication 和 Disassociation 携带的与帧等级有关的 Reason Code 如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;6：在未身份验证的状态下接收到了第 2 级帧&lt;/li&gt;
  &lt;li&gt;7：在未关联的状态下接收了第 3 级帧&lt;/li&gt;
  &lt;li&gt;9：STA 未通过身份验证便请求关联&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;六总结&quot;&gt;六、总结&lt;/h2&gt;

&lt;p&gt;经过梳理，我们了解到，WLAN 的安全系统主要由身份认证、密钥管理和加密传输等部分组成，WEP 是最早的安全机制，802.11i 是后来推出的安全标准，WPA/WPA2 则是 Wi-Fi 联盟推出的这一标准子集的实现。802.11i 标准中，身份认证基于802.1X，而 802.1X 基于 EAP，密钥管理和加密传输则基于 TKIP、CCMP 等协议。&lt;/p&gt;

&lt;p&gt;生活中常见的安全系统有 WEP、WPA/WPA2、WAPI 等等，配置安全系统时，管理员设定这些安全服务所使用的安全技术，形成一套安全策略。下表列举几种安全策略：&lt;/p&gt;

&lt;div class=&quot;table-wrapper&quot;&gt;
  &lt;table&gt;&lt;caption&gt;
        WLAN 安全策略

    &lt;/caption&gt;

  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;安全策略&lt;/th&gt;
      &lt;th&gt;链路认证&lt;/th&gt;
      &lt;th&gt;接入认证&lt;/th&gt;
      &lt;th&gt;数据加密&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;WEP&lt;/td&gt;
      &lt;td&gt;Open&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
      &lt;td&gt;不加密或 WEP 加密&lt;/td&gt;
      &lt;td&gt;不安全&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;^^&lt;/td&gt;
      &lt;td&gt;SKA&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
      &lt;td&gt;WEP&lt;/td&gt;
      &lt;td&gt;^^&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WPA/WPA2-PSK&lt;/td&gt;
      &lt;td&gt;Open&lt;/td&gt;
      &lt;td&gt;PSK&lt;/td&gt;
      &lt;td&gt;TKIP 或 CCMP&lt;/td&gt;
      &lt;td&gt;目前常用的是 WPA2-PSK，适用于个人和企业&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WPA/WPA2-Enterprise&lt;/td&gt;
      &lt;td&gt;Open&lt;/td&gt;
      &lt;td&gt;802.1X（EAPoL）&lt;/td&gt;
      &lt;td&gt;TKIP 或 CCMP&lt;/td&gt;
      &lt;td&gt;目前常用的是 WPA2-Enterprise，适用于企业&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WAPI-PSK&lt;/td&gt;
      &lt;td&gt;Open&lt;/td&gt;
      &lt;td&gt;PSK&lt;/td&gt;
      &lt;td&gt;SMS4&lt;/td&gt;
      &lt;td&gt;应用较少&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WAPI-CERT&lt;/td&gt;
      &lt;td&gt;Open&lt;/td&gt;
      &lt;td&gt;证书认证&lt;/td&gt;
      &lt;td&gt;SMS4&lt;/td&gt;
      &lt;td&gt;^^&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;/div&gt;

&lt;p&gt;到这里，应该就有一个关于 WLAN 安全的认知框架了。&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Clint Chaplin, Emily Qi, Henry Ptasinski, Jesse Walker, Sheung Li. 802.11i Overview[EB/OL]. &lt;a href=&quot;https://www.ieee802.org/16/liaison/docs/80211-05_0123r1.pdf&quot;&gt;URL&lt;/a&gt;, 2005-02-09. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:1:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Gast, M. S. 802.11® 无线网络权威指南[M]. 第 2 版. O’Reilly Taiwan 公司. 南京 - 东南大学出版社, 2007.12: 142-195,123-126。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:2:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Lnki</name></author><category term="技术" /><category term="网络" /><category term="WLAN" /><category term="安全" /><summary type="html">WLAN 物理层的传输方式都是无线电广播，由于物理媒介的开放性，避免窃听自然是 WLAN 要提供的一项基本功能。说到 WLAN 安全，我们会想到 802.11i、802.1X、WEP、WPA、EAP、WAPI 等一堆名词，本文介绍它们的概念和作用，并梳理它们的关系。</summary></entry><entry><title type="html">IEEE 802.11 MAC 帧</title><link href="https://www.lnki.me/2018/09/wlan-frame/" rel="alternate" type="text/html" title="IEEE 802.11 MAC 帧" /><published>2018-09-13T00:00:00+08:00</published><updated>2018-09-13T00:00:00+08:00</updated><id>https://www.lnki.me/2018/09/wlan-frame</id><content type="html" xml:base="https://www.lnki.me/2018/09/wlan-frame/">&lt;p&gt;Ehternet 的成帧很简单，只需在前加上前导码、寻址信息并在结尾加上校验和，相比而言，802.11 的成帧复杂，因为无线网络需要加入较多控制和管理的功能。&lt;/p&gt;

&lt;h2 id=&quot;一帧格式&quot;&gt;一、帧格式&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;

&lt;p&gt;下图为一般的 802.11 MAC 帧格式，单位为字节，会用到哪些字段取决于帧的类型。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-general-frame.webp&quot; alt=&quot;一般的 802.11 帧格式示意图&quot; /&gt;
  &lt;figcaption&gt;
      一般的 802.11 MAC 帧格式

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;Frame Control&lt;/dt&gt;
  &lt;dd&gt;帧控制字段，包含协议、帧类型以及标志位等信息。其中 Type 字段标记当前帧的类型，包括管理帧、控制帧、数据帧三类；Sub-type 字段标记每种帧类型中的子类型，不同类型的帧有不同的处理方式。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-frame-frame-control.webp&quot; alt=&quot;Frame Control 字段示意图&quot; /&gt;
  &lt;figcaption&gt;
      Frame Control 字段

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;Duration / ID&lt;/dt&gt;
  &lt;dd&gt;这个字段有三种形式，如下图。设定 NAV 时，第 15 位为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;，其他位标识 NAV 的值，单位为微秒；在无竞争周期传送的帧中，第 14、15 位为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;01&lt;/code&gt;，其余位均为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;，用来公告所有 STA 网络无竞争周期，避免它们干扰传送；在 PS-Poll（省电轮询）帧中，第 14、15 位为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11&lt;/code&gt;，其他位则表示 AID（Association ID），AP 用来查找相应的缓冲帧。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-frame-nav-id.webp&quot; alt=&quot;Duration / ID 字段示意图&quot; /&gt;
  &lt;figcaption&gt;
      Duration / ID 字段的表示形式

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;Address&lt;/dt&gt;
  &lt;dd&gt;802.11 帧最多包含 4 个地址字段，不同类型的帧包含的地址字段数量有所不同，它们可能表示目的地址（最终的接收端）、来源地址（帧的来源）、接收端地址（负责接收处理该帧的无线设备，可以是 STA 或 AP）、发送端地址（将帧传至无线媒介的无线接口）或者 BSSID（在基础结构型网络里是 AP 的 MAC 地址，在独立型网络则为随机的值）。&lt;/dd&gt;
  &lt;dt&gt;Sequence Control&lt;/dt&gt;
  &lt;dd&gt;分为片段编号和顺序编号，用于重组片段和丢弃重复帧。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-frame-seq-ctrl.webp&quot; alt=&quot;Sequence Control 字段示意图&quot; /&gt;
  &lt;figcaption&gt;
      Sequence Control 字段

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;Frame Body&lt;/dt&gt;
  &lt;dd&gt;帧主体，负责传递上层有效载荷（Payload）。&lt;/dd&gt;
  &lt;dt&gt;FCS（Frame Check Sequence）&lt;/dt&gt;
  &lt;dd&gt;帧校验序列，是一种 32 bit 长的循环冗余校验码（CRC），FCS 和 CRC 的底层算法相同，用于检查所收到的帧的完整性。&lt;/dd&gt;
&lt;/dl&gt;

&lt;h2 id=&quot;二对上层协议的封装&quot;&gt;二、对上层协议的封装&lt;/h2&gt;

&lt;p&gt;和以太网不同，802.11 封装依靠 802.2 的逻辑链路层封装来携带上层数据包。封装三层数据包时，先由衍生自 802.2 子网访问协议（SNAP，Sub-network Access Protocol）的 RFC 1042 或 802.1h 封装，SNAP 标头以目的服务接入点（DSAP，Destination Service Access Point）和源服务接入点（SSAP，Source Service Access Point）开始，之后依次为控制、OUI（组织唯一标识）、数据包类型字段，最后是数据包主体。LLC 层封装后，802.11 会再添加 MAC 标头，填入目的地址、源地址等信息，最后计算数据帧的帧校验序列，加到帧的末尾。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-frame-ip-encap.webp&quot; alt=&quot;IEEE 802.11 封装 IP 示意图&quot; /&gt;
  &lt;figcaption&gt;
      IEEE 802.11 对 IP 的封装

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;h2 id=&quot;三帧类型&quot;&gt;三、帧类型&lt;sup id=&quot;fnref:1:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;

&lt;p&gt;前面有提到，802.11 MAC 帧分为三类，分别为数据帧、控制帧和管理帧，本节介绍各种帧的特点及作用。&lt;/p&gt;

&lt;h3 id=&quot;1-数据帧&quot;&gt;1. 数据帧&lt;/h3&gt;

&lt;p&gt;数据帧主要负责承载数据的传输，将上层协议的数据置于帧主体中加以传递，此外它还标记数据的传输方式，例如 QoS、CF-Poll 等等。控制帧和管理帧不承载上层数据包。数据帧子类型包括下面这些：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Data&lt;/li&gt;
  &lt;li&gt;Data + CF-ACK&lt;/li&gt;
  &lt;li&gt;Data + CF-Poll&lt;/li&gt;
  &lt;li&gt;Data + CF-ACK + CF-Poll&lt;/li&gt;
  &lt;li&gt;Null（无承载数据）&lt;/li&gt;
  &lt;li&gt;CF-ACK（无承载数据）&lt;/li&gt;
  &lt;li&gt;CF-Poll（无承载数据）&lt;/li&gt;
  &lt;li&gt;CF-ACK + CF-Poll（无承载数据）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，802.11e 提议引入 QoS，但尚未标准化，Sub-type 字段首位为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 则表示启用了 QoS 支持，因此，有人称第一位为 QoS 位。&lt;/p&gt;

&lt;h3 id=&quot;2-控制帧&quot;&gt;2. 控制帧&lt;/h3&gt;

&lt;p&gt;控制帧负责管理媒介的访问权，避免物理链路发生冲突，并且确保帧被成功传输，提供 MAC 层的可靠性，此外还包括省电程序；&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;RTS 帧&lt;/dt&gt;
  &lt;dd&gt;用来预约无线链路的使用权，为了确保传输数据时不会有冲突，会先发送一个 RTS 帧，其他设备收到 RTS 帧后，会在一段时间内保持静默。&lt;/dd&gt;
  &lt;dt&gt;CTS 帧&lt;/dt&gt;
  &lt;dd&gt;用于应答 RTS 帧，接收端收到 RTS 帧后，如果没有冲突，便应答一个 CTS 帧，标识当前无线链路可用，CTS 帧同样会使其他设备保持静默，如果发送端发送 RTS 后没有收到 CTS，便判定物理链路忙碌，将在一段时间内保持静默。&lt;/dd&gt;
  &lt;dt&gt;ACK 帧&lt;/dt&gt;
  &lt;dd&gt;确认数据已正确传输，接收端正确接数据后，应答一个 ACK 帧，若发送端未收到 ACK，则认为传输失败，将重传数据，以此实现传输的可靠性。&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;这里提一下，802.11 网络中的物理链路访问控制和传输可靠性主要依靠的就是 RTS、CTS、ACK。&lt;/p&gt;

&lt;p&gt;在传输大型帧时干扰较多，需要用 RTS 来取得媒介的访问权。网卡驱动会设置一个 RTS 阈值，传送大于 RTS 阈值的帧之前，先进行 RTS / CTS 交换，先向接收端发送 RTS 帧，接收端收到 RTS 后应答 CTS 帧，以此清空物理链路，然后发送端再发送数据帧，接收端正确接收后，应答ACK；至于长度小于 RTS 阈值的帧，则不进行 RTS / CTS 交换，直接发送数据帧，然后接收端应答 ACK。上述流程中，每个帧之间都间隔 SIFS，流程结束后进入 DIFS，DIFS 结束后网络中的设备再次开始竞争物理链路使用权。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-rtc-cts-ack.webp&quot; alt=&quot;RTS / CTS 清空物理链路示意图&quot; /&gt;
  &lt;figcaption&gt;
      传输长度大于 RTS 阈值的帧

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;PS-Poll 帧&lt;/dt&gt;
  &lt;dd&gt;控制帧的子类型中还包括 PS-Poll 帧，参与 802.11 的省电程序机制，用于从 AP 获取缓存帧。PS-Poll 帧中包含一个 AID 字段，AID（Association ID）即关联 ID，用于识别关联，便于 AP 为该关联找出缓存的帧。&lt;/dd&gt;
  &lt;dt&gt;CF-End 帧&lt;/dt&gt;
  &lt;dd&gt;表示无竞争周期结束。&lt;/dd&gt;
  &lt;dt&gt;CF-End + CF-ACK 帧&lt;/dt&gt;
  &lt;dd&gt;表示无竞争周期结束，同时进行无竞争周期确认。&lt;/dd&gt;
&lt;/dl&gt;

&lt;h3 id=&quot;3-管理帧&quot;&gt;3. 管理帧&lt;/h3&gt;

&lt;p&gt;管理帧主要负责网络的访问控制，参与 WLAN 的连接、断开、身份验证等操作，以及进行 WLAN 的识别，使无线网络能实现类似传统有线网络的寻找插座、连接网线等操作。与控制帧相比，控制帧管理的是数据传输的过程，而管理帧管理的是无线网络本身。管理帧包含帧主体，可以携带一些固定字段或是信息元素，以传递详细的网络管理消息，例如 SSID、WPA 密钥等等。&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;Beacon 帧&lt;/dt&gt;
  &lt;dd&gt;一种比较重要的类型，用于声明网络的存在，是网络的信标，其中包含 SSID、BSSID 等字段，以及加入网络所需的参数，周期性传送信标可以让 STA 得知网络的存在。&lt;/dd&gt;
  &lt;dt&gt;Probe Request 帧&lt;/dt&gt;
  &lt;dd&gt;探查请求，用来扫描区域内的 802.11 网络，它包含要探查的 SSID 和 STA 支持的频率信息，收到 Probe Request 帧的 AP 会判断 STA 是否能加入网络。&lt;/dd&gt;
  &lt;dt&gt;Probe Response 帧&lt;/dt&gt;
  &lt;dd&gt;即探查响应，收到 Probe Request 帧后，若 STA 与网络兼容，AP 就会应答一个 Probe Response 帧。Probe Response 包含 Beacon 中的所有参数，STA 根据它调整加入网络所需的参数。&lt;/dd&gt;
  &lt;dt&gt;ATIM 帧&lt;/dt&gt;
  &lt;dd&gt;Announcement Traffic Indication Message 即通知传输指示消息，用于 IBSS 的省电机制，某台设备休眠时，会发出一个 ATIM 帧，此后发往该设备的帧会被发送方缓存。&lt;/dd&gt;
  &lt;dt&gt;Authentication 帧&lt;/dt&gt;
  &lt;dd&gt;用于建立连接前的身份验证，帧中包含算法代号，由于使用的算法不同，认证过程可能包含多个步骤，因此要为每个 Authentication 帧标记序号，状态码和质询文本因算法而异。&lt;/dd&gt;
  &lt;dt&gt;Association Request 帧&lt;/dt&gt;
  &lt;dd&gt;用来请求加入网络，STA 判断与网络兼容并通过身份验证后，便会发送 Association Request 帧 请求关联。&lt;/dd&gt;
  &lt;dt&gt;Association Response 帧与Reassociation Response 帧&lt;/dt&gt;
  &lt;dd&gt;分别用于关联请求和重新关联请求的响应，在响应过程中，会为当前关联指定 AID，(Re)Association Response 帧传输完成后关联关系建立。&lt;/dd&gt;
  &lt;dt&gt;Reassociation Request 帧&lt;/dt&gt;
  &lt;dd&gt;主要用于同一 ESS 内的 BSS 切换过程，允许 STA 短暂离开网络后重新加入，相较于 Association Request 帧，Reassociation Request 帧包含 STA 此前关联的 AP 的 MAC 地址，这样新旧 AP 可以彼此联系和转移缓存的数据。&lt;/dd&gt;
  &lt;dt&gt;Disassociation 帧与 Deauthentication 帧&lt;/dt&gt;
  &lt;dd&gt;分别用于解除关联关系和认证关系，两者均包含一个 Reason 字段，用于描述解除关系的原因。在解除认证关系时会自动解除关联关系。&lt;/dd&gt;
  &lt;dt&gt;Action 帧&lt;/dt&gt;
  &lt;dd&gt;由 802.11h 引入，用于其他功能，例如 DFS。&lt;/dd&gt;
&lt;/dl&gt;

&lt;h2 id=&quot;四帧的内容&quot;&gt;四、帧的内容&lt;/h2&gt;

&lt;p&gt;到这里，我们已经了解到，802.11 MAC 设计了多种类型的帧来保证 WLAN 正常工作，为了理解成帧细节，下面就以 Beacon 帧为例，抓包看看 802.11 MAC 帧的内容。&lt;/p&gt;

&lt;p&gt;首先 Beacon 帧的 MAC 标头长度为 24 字节。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-beacon-header.webp&quot; alt=&quot;Beacon 帧 MAC 标头图&quot; /&gt;
  &lt;figcaption&gt;
      Beacon 帧中的 MAC 标头

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;Frame Control（2 字节）&lt;/dt&gt;
  &lt;dd&gt;其中协议版本（2 bit）为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;，帧类型（2 bit）为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;00&lt;/code&gt;（管理帧），子类型（4 bit）为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000&lt;/code&gt;（Beacon 帧），标志位（8 bit）全部置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-beacon-frame-ctrl.webp&quot; alt=&quot;Beacon 帧 Frame Control 字段内容图&quot; /&gt;
  &lt;figcaption&gt;
      Frame Control 字段内容

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;Duration 字段（2 字节）&lt;/dt&gt;
  &lt;dd&gt;值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;，表示 NAV 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;，不进行计时。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-beacon-duration.webp&quot; alt=&quot;Beacon 帧 Duration 字段内容图&quot; /&gt;
  &lt;figcaption&gt;
      Duration 字段内容

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;目的地址（6 字节）&lt;/dt&gt;
  &lt;dd&gt;值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ff:ff:ff:ff:ff:ff&lt;/code&gt;，广播地址，Beacon 帧的定义中没有接收端地址。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-beacon-da.webp&quot; alt=&quot;Beacon 帧目的地址图&quot; /&gt;
  &lt;figcaption&gt;
      目的地址

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;源地址（6 字节）&lt;/dt&gt;
  &lt;dd&gt;值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;96:63:72:0e:9f:e1&lt;/code&gt;，同样地，Beacon 帧的定义中没有发送端地址。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-beacon-sa.webp&quot; alt=&quot;Beacon 帧源地址图&quot; /&gt;
  &lt;figcaption&gt;
      源地址

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;BSSID（6 字节）&lt;/dt&gt;
  &lt;dd&gt;值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;96:63:72:0e:9f:e1&lt;/code&gt;，与源地址相同，以 AP 的 MAC 地址作为 BSSID。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-beacon-bssid.webp&quot; alt=&quot;Beacon 帧 BSSID 字段内容图&quot; /&gt;
  &lt;figcaption&gt;
      BSSID 字段内容

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;帧分片序号（4 bit）&lt;/dt&gt;
  &lt;dd&gt;值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;，表示不分片；帧序列号（12 bit）为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;694&lt;/code&gt;。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-beacon-fragment-seq.webp&quot; alt=&quot;Beacon 帧分片序号与序列号字段内容图&quot; /&gt;
  &lt;figcaption&gt;
      分片序号与序列号

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;帧校验序列（4 bit）&lt;/dt&gt;
  &lt;dd&gt;在帧主体后面，帧的结尾处，值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xEA820968&lt;/code&gt;，显示校验结果正确，数据完整。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-beacon-fcs.webp&quot; alt=&quot;Beacon 帧校验序列内容图&quot; /&gt;
  &lt;figcaption&gt;
      帧校验序列字段内容

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;Beacon 帧主体&lt;/dt&gt;
  &lt;dd&gt;分为固定长度的固定字段（Fixed Parameters）和长度不定的标签字段（Tagged Parameters）。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-beacon-body.webp&quot; alt=&quot;Beacon 帧主体内容图&quot; /&gt;
  &lt;figcaption&gt;
      Beacon 帧主体

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;信息元素：SSID&lt;/dt&gt;
  &lt;dd&gt;最后看看 Beacon 帧主体中的标签字段 SSID，每个标签字段也称为信息元素（Information Element，EI），是长度不定的字符串，SSID 长度介于 0 至 32 字节之间，元素编号（1 字节）为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;，长度（1 字节）为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10&lt;/code&gt;，无线网络的 SSID 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vivo NEX S&lt;/code&gt;。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-beacon-tag-ssid.webp&quot; alt=&quot;Beacon 帧 SSID 标签内容图&quot; /&gt;
  &lt;figcaption&gt;
      SSID 标签

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;

&lt;p&gt;分析完 802.11 MAC 帧的部分细节，对 802.11 工作原理有了一个系统化的、动态的认识，了解了一些典型机制的基本原理，比如可靠性传输、竞争周期、建立连接、扫描的过程等等，将日常使用 Wi-Fi 的操作和这些帧对应起来，就明白我们通过 Wi-Fi 上网时，设备之间究竟发生了什么。当然，这里也不可能了解 802.11 MAC 帧的全部内容，更多原理有待后续学习。&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Gast, M. S. 802.11® 无线网络权威指南[M]. 第 2 版. O’Reilly Taiwan 公司. 南京 - 东南大学出版社, 2007.12: 57-66,88-105 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:1:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Lnki</name></author><category term="技术" /><category term="网络" /><category term="WLAN" /><summary type="html">Ehternet 的成帧很简单，只需在前加上前导码、寻址信息并在结尾加上校验和，相比而言，802.11 的成帧复杂，因为无线网络需要加入较多控制和管理的功能。</summary></entry><entry><title type="html">IEEE 802.11 MAC 基础盘点</title><link href="https://www.lnki.me/2018/09/wlan-mac/" rel="alternate" type="text/html" title="IEEE 802.11 MAC 基础盘点" /><published>2018-09-12T00:00:00+08:00</published><updated>2018-09-12T00:00:00+08:00</updated><id>https://www.lnki.me/2018/09/wlan-mac</id><content type="html" xml:base="https://www.lnki.me/2018/09/wlan-mac/">&lt;p&gt;这里简单过一过 IEEE 802.11 MAC 层的常见概念&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，了解这些名词基本的的用途和目的，具体原理就不做深入讨论了。&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;MAC（Media Access Control）&lt;/dt&gt;
  &lt;dd&gt;OSI 模型数据链路层子层，直接管理传输媒介，将传输媒介抽象为物理链路，负责物理链路冲突的避免、进行帧的封装与解封、错误检测和主机定位。&lt;/dd&gt;
  &lt;dt&gt;主动确认（Positive ACK）&lt;/dt&gt;
  &lt;dd&gt;由于无线链路的特殊性，传输会受到噪声和干扰的影响，802.11 采用主动确认的机制，所有传出去的帧必须得到回应，否则认为传输漏失，会进行重传。&lt;/dd&gt;
  &lt;dt&gt;隐藏节点问题&lt;/dt&gt;
  &lt;dd&gt;假设下图中节点 2 可以直接和节点 1、3 直接通信，但由于某些原因节点 1 无法直接接收到节点 3 的信号，对于节点 1 而言，节点 3 就是隐藏节点。节点 1、3 可能同时向节点 2 发送数据，节点 2 同时收到来自两边的数据便会出现异常，而且节点 1、3 也无从得知发生了错误。&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-mac-hidden-node.webp&quot; alt=&quot;隐藏节点问题示意图&quot; /&gt;
  &lt;figcaption&gt;
      隐藏节点

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;RTS（Request to Send）&lt;/dt&gt;
  &lt;dd&gt;为了解决隐藏节点问题，防止冲突发生，802.11 引入 RTS / CTS 机制，发送端在发送数据前，会先发送一个 RTS 帧，预约无线链路的使用权，其他 STA 收到 RTS 帧后，会在一段时间内保持静默。&lt;/dd&gt;
  &lt;dt&gt;CTS（Clear to Send）&lt;/dt&gt;
  &lt;dd&gt;接收端收到 RTS 帧后，便应答一个 CTS 帧，标识当前无线链路可用，同时 CTS 帧会使其他 STA 保持静默。&lt;/dd&gt;
  &lt;dt&gt;RTS 阈值&lt;/dt&gt;
  &lt;dd&gt;RTS / CTS 交换过程会消耗一定的带宽，在规模不大、接入 STA 较少的无线网络中，很少出现同时传输的情况，且有不少闲置带宽可供重传。RTS 阈值提供了一个折中的冲突控制方案，若帧长度大于阈值，则需要进行 RTS / CTS 交换，否则直接传送帧。&lt;/dd&gt;
  &lt;dt&gt;DCF（Distributed Coordination Function）&lt;/dt&gt;
  &lt;dd&gt;分布式协调功能，是 CSMA/CA 访问机制的基础。传送数据前，先检测无线链路是否处于清空状态，如果有冲突，STA 会随机为每个帧设定一段退避（Backoff）时间，在这段时间内保持静默。&lt;/dd&gt;
  &lt;dt&gt;PCF（Point Coordination Function）&lt;/dt&gt;
  &lt;dd&gt;点协调功能，提供无竞争服务，由 AP 扮演协调者的角色，统一协调安排各终端对无线链路的访问，使其不必通过竞争即可以使用媒介。&lt;/dd&gt;
  &lt;dt&gt;HCF（Hybrid Coordination Function）&lt;/dt&gt;
  &lt;dd&gt;混合协调功能，介于 DCF 和 PCF 之间，尚未完全标准化。&lt;/dd&gt;
  &lt;dt&gt;CSMA/CD（Carrier Sense Multiple Access with Collision Detection）&lt;/dt&gt;
  &lt;dd&gt;带冲突监测的载波监听多路访问技术，发送数据时，先听后发，边发边听，遇到冲突停发，随机延迟后重发。&lt;/dd&gt;
  &lt;dt&gt;CSMA/CA（CSMA with Collision Avoidance）&lt;/dt&gt;
  &lt;dd&gt;带冲突避免的载波监听多路访问技术，基于 CSMA/CD 改进，监听到空闲并维持一段时间后，才发送数据，接收端正确接收后，延迟应答 ACK，发送端收到 ACK，确定数据正确传输，然后进入空闲状态。&lt;/dd&gt;
  &lt;dt&gt;NAV（Network Access Vector）&lt;/dt&gt;
  &lt;dd&gt;网络访问矢量，用于虚拟载波监听，本质上是一个计时器，RTS 和 CTS 携带有 NAV 时间信息，其他 STA 收到这些帧后会依据 NAV 开始计时，NAV 非零时物理链路被视为忙碌，期间保持静默，直到 NAV 归零后，才会继续传输。&lt;/dd&gt;
  &lt;dt&gt;IFS（Interframe Space）&lt;/dt&gt;
  &lt;dd&gt;帧间间隔，是在传输完一个帧后，物理链路从忙碌状态推出后的一段等待时间，用于协调媒介访问。IFS 有几种，如下图：&lt;/dd&gt;
&lt;/dl&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-mac-ifs.webp&quot; alt=&quot;各种帧间隔关系图&quot; /&gt;
  &lt;figcaption&gt;
      各种 IFS 的关系

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;dl&gt;
  &lt;dt&gt;SIFS（Short IFS）&lt;/dt&gt;
  &lt;dd&gt;短帧间间隔，用于优先级较高的传输，例如 RTS、CTS、ACK 等，这些帧在 SIFS 结束后即可进行传输。&lt;/dd&gt;
  &lt;dt&gt;PIFS（PCF IFS）&lt;/dt&gt;
  &lt;dd&gt;用于 PCF，在无竞争时期，有数据待传的 STA 可以等待 PIFS 结束后再传，其优先级高于任何竞争式传输。&lt;/dd&gt;
  &lt;dt&gt;DIFS（DCF IFS）&lt;/dt&gt;
  &lt;dd&gt;用于 DCF，是竞争式服务中最短的媒介闲置时间，若媒介限制时间长于 DIFS，则 STA 可以立即访问媒介。&lt;/dd&gt;
  &lt;dt&gt;EIFS（Extended IFS）&lt;/dt&gt;
  &lt;dd&gt;长度不固定，只在帧传输出现错误时用到。&lt;/dd&gt;
  &lt;dt&gt;DCF 退避算法&lt;/dt&gt;
  &lt;dd&gt;当帧传输完成并经过 DIFS 后，STA 尝试重新传送堵塞的数据。紧接着 DIFS 的是竞争窗口，也被称为退避窗口，当帧传输失败时，该窗口会扩大，以减缓网络拥塞程度。&lt;/dd&gt;
  &lt;dt&gt;单播确认、广播不确认&lt;/dt&gt;
  &lt;dd&gt;尽管无线电是一种广播介质，但因为加入了单播的 QoS 机制，实际上单播传输质量高于广播。&lt;/dd&gt;
  &lt;dt&gt;帧分段和重组&lt;/dt&gt;
  &lt;dd&gt;由于物理属性的限制，来自上层的大型数据包可能需要分段封装后，才能由无线电媒介传输，并有助于抗干扰，提升通信可靠性。接收端收到分段的帧后，再重新组合为原始帧。&lt;/dd&gt;
  &lt;dt&gt;片段突发期&lt;/dt&gt;
  &lt;dd&gt;这段时期，帧分段会连续传输，每个帧片段以 SIFS 分隔，STA 会一直占有媒介访问权。&lt;/dd&gt;
  &lt;dt&gt;省电程序（Powersaving Sequence）&lt;/dt&gt;
  &lt;dd&gt;为了省电，STA 会定期休眠，期间 AP 为其缓存单播帧，STA 苏醒后使用 PS-Poll 帧从 AP 取得这些缓存帧。&lt;/dd&gt;
&lt;/dl&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Gast, M. S. 802.11® 无线网络权威指南[M]. 第 2 版. O’Reilly Taiwan 公司. 南京 - 东南大学出版社, 2007.12: 43-73 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Lnki</name></author><category term="技术" /><category term="网络" /><category term="WLAN" /><summary type="html">这里简单过一过 IEEE 802.11 MAC 层的常见概念1，了解这些名词基本的的用途和目的，具体原理就不做深入讨论了。 Gast, M. S. 802.11® 无线网络权威指南[M]. 第 2 版. O’Reilly Taiwan 公司. 南京 - 东南大学出版社, 2007.12: 43-73 &amp;#8617;</summary></entry><entry><title type="html">IEEE 802.11 概览</title><link href="https://www.lnki.me/2018/09/wlan-overview/" rel="alternate" type="text/html" title="IEEE 802.11 概览" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>https://www.lnki.me/2018/09/wlan-overview</id><content type="html" xml:base="https://www.lnki.me/2018/09/wlan-overview/">&lt;p&gt;关于无线网络，我们常提到 WLAN、Wi-Fi、IEEE 802.11 a/b/g/n/ac 等名词，它们似乎都可以指无线网络，这里先了解它们的概念和区别：&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;WLAN&lt;/dt&gt;
  &lt;dd&gt;Wireless LAN，即无线局域网，一种局域网形式，物理介质为无线电波&lt;/dd&gt;
  &lt;dt&gt;IEEE 802.11&lt;/dt&gt;
  &lt;dd&gt;由 IEEE 制定的无线网络标准，a/b/g/n/ac 是该标准的几个迭代版本，IEEE 802.11 是现今 WLAN 的通用标准&lt;/dd&gt;
  &lt;dt&gt;Wi-Fi&lt;/dt&gt;
  &lt;dd&gt;一种基于 IEEE 802.11 标准的技术实现，是现今 WLAN 最常采用的技术，它也是 Wi-Fi 联盟的商用标志，用于产品的 WLAN 技术认证。&lt;/dd&gt;
&lt;/dl&gt;

&lt;h2 id=&quot;一背景&quot;&gt;一、背景&lt;/h2&gt;

&lt;h3 id=&quot;1-技术族谱&quot;&gt;1. 技术族谱&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;

&lt;p&gt;IEEE 802 家族由一系列局域网标准组成，主要对 OSI 参考模型的最下面两层作出规范，涵盖了物理层和数据链路层组件。IEEE 802.11 是无线局域网标准，提供了物理层和 MAC 的规范。IEEE 802.11 与以太网有较深的渊源，被称为“无线以太网”，在配置 IEEE 802.11 网络时，不需要对传统的以太网做很多调整便可以将服务扩展至无线网络中，为网络设备带来了可移动性。&lt;/p&gt;

&lt;p&gt;下图是部分 IEEE 802 家族的成员，可以看到家族成员之间的关系及其在 OSI 模型中的角色定位：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/ieee802-family.webp&quot; alt=&quot;IEEE 802 家族图&quot; /&gt;
  &lt;figcaption&gt;
      IEEE 802 家族

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;IEEE 802.11 涵盖了 OSI 模型的物理层和数据链路层，将物理层进一步细分为 PLCP 和 PMD 两个子层，PLCP（Physical Layer Convergence Procedure）负责将 MAC 映射到传输媒介，PMD（Physical Medium Dependent）负责帧的传送。分层结构如下图：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/ieee80211-phy-mac.webp&quot; alt=&quot;IEEE 802.11 PHY 组件图&quot; /&gt;
  &lt;figcaption&gt;
      IEEE 802.11 物理层结构

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;目前 IEEE 802.11 已被淘汰，由 IEEE 802.11a/b/g/n/ac 等修订标准替代，各修订版本主要是针对物理层做优化。下表是各版本的特性及差异：&lt;/p&gt;

&lt;div class=&quot;table-wrapper&quot;&gt;
  &lt;table&gt;&lt;caption&gt;
        &lt;a href=&quot;https://zh.wikipedia.org/wiki/IEEE_802.11ac&quot;&gt;IEEE 802.11 版本比较&lt;/a&gt;

    &lt;/caption&gt;

  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;标准&lt;/th&gt;
      &lt;th&gt;频段&lt;/th&gt;
      &lt;th&gt;最大带宽&lt;/th&gt;
      &lt;th&gt;调制方式&lt;/th&gt;
      &lt;th&gt;最大传输速率&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;802.11&lt;/td&gt;
      &lt;td&gt;2.4 GHz&lt;/td&gt;
      &lt;td&gt;20 MHz&lt;/td&gt;
      &lt;td&gt;FHSS&lt;br /&gt;DSSS&lt;/td&gt;
      &lt;td&gt;2 Mbps&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;802.11a&lt;/td&gt;
      &lt;td&gt;5 GHz&lt;/td&gt;
      &lt;td&gt;20 MHz&lt;/td&gt;
      &lt;td&gt;OFDM&lt;/td&gt;
      &lt;td&gt;54 Mbps&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;802.11b&lt;/td&gt;
      &lt;td&gt;2.4 GHz&lt;/td&gt;
      &lt;td&gt;20 MHz&lt;/td&gt;
      &lt;td&gt;HR-DSSS&lt;/td&gt;
      &lt;td&gt;11 Mbps&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;802.11g&lt;/td&gt;
      &lt;td&gt;2.4 GHz&lt;/td&gt;
      &lt;td&gt;20 MHz&lt;/td&gt;
      &lt;td&gt;OFDM&lt;/td&gt;
      &lt;td&gt;54 Mbps&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;802.11n&lt;/td&gt;
      &lt;td&gt;2.4 GHz&lt;br /&gt;5 GHz&lt;/td&gt;
      &lt;td&gt;40 MHz&lt;/td&gt;
      &lt;td&gt;MIMO-OFDM&lt;/td&gt;
      &lt;td&gt;150 Mbps (40 MHz 1x1)&lt;br /&gt;600 Mbps (40MHz 4x4)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;802.11ac Wave 1&lt;/td&gt;
      &lt;td&gt;5 GHz&lt;/td&gt;
      &lt;td&gt;80 MHz&lt;/td&gt;
      &lt;td&gt;MIMO-OFDM&lt;/td&gt;
      &lt;td&gt;433.3 Mbps (80 MHz 1x1)&lt;br /&gt;1.3 Gbps (80 MHz 3x3)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;802.11ac Wave 2&lt;/td&gt;
      &lt;td&gt;5 GHz&lt;/td&gt;
      &lt;td&gt;160 MHz&lt;/td&gt;
      &lt;td&gt;MIMO-OFDM&lt;/td&gt;
      &lt;td&gt;866.7 Mbps (160 MHz 1x1)&lt;br /&gt;6.9 Gbps (160 MHz 8x8)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;/div&gt;

&lt;p&gt;IEEE 802.11ac 有两个细分版本，Wave 1 于 2014 年发布，支持 80 MHz 带宽和 3x3 SU-MIMO，Wave 2 于2016 年发布，增加了对 160 MHz 带宽和 8x8 MU-MIMO 的支持，提供更高吞吐量。&lt;/p&gt;

&lt;h3 id=&quot;2-有关组织&quot;&gt;2. 有关组织&lt;/h3&gt;

&lt;h4 id=&quot;ieee-institute-of-electrical-and-electronics-engineers&quot;&gt;IEEE (Institute of Electrical and Electronics Engineers)&lt;/h4&gt;

&lt;p&gt;电气电子工程师协会，是一个非营利性的电子技术和信息工程师的协会，被国际标准化组织授权为可以指定标准的组织，设有众多标准委员会，其中最为著名的是IEEE 802委员会，致力于局域网标准的制定。&lt;/p&gt;

&lt;h4 id=&quot;wi-fi-alliance&quot;&gt;Wi-Fi Alliance&lt;/h4&gt;

&lt;p&gt;Wi-Fi 联盟，是由行业众多公司组建的商业联盟，拥有 Wi-Fi 商标，主要负责建立和执行无线网络标准、优化互操作性与兼容性，并推动无线网络技术，主要业务是无限相容性认证，通过认证的需要符合 IEEE 802.11 无线标准、WPA/WPA2 安全标准、EAP 认证标准。&lt;/p&gt;

&lt;h2 id=&quot;二一些物理层的概念&quot;&gt;二、一些物理层的概念&lt;/h2&gt;

&lt;h3 id=&quot;1-频段和信道&quot;&gt;1. 频段和信道&lt;/h3&gt;

&lt;p&gt;802.11 工作组为 WLAN 划分了 4 个独立的频段：2.4 GHz、3.6 GHz、4.9 GHz 和 5.8 GHz，每个频段又划分为若干信道。对于这些频段和信道的使用，各个国家制定的政策有所不同，内容包括最大发射功率、调制方式等。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/1920px-2.4_GHz_Wi-Fi_channels_(802.11b,g_WLAN).svg.webp&quot; alt=&quot;WLAN 2.4 GHz 信道图&quot; /&gt;
  &lt;figcaption&gt;
      &lt;a href=&quot;https://zh.wikipedia.org/wiki/WLAN%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8&quot;&gt;WLAN 2.4 GHz 信道&lt;/a&gt;

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;WLAN 在 2.4 GHz 频段可以使用的具体频率是 2.412 GHz ~ 2.472 GHz（信道中心频率），总共是 80 MHz 的带宽，这个频段划分出 13 个相互重叠的信道，在 OFDM 调制中，每个信道的带宽是 20 MHz（DSSS调制是 22 MHz），换言之，2.4 GHz频段工作时只有三个互不干扰的信道，分别为 1、6、11。&lt;/p&gt;

&lt;p&gt;5 GHz 频段的频率是 4.915GHz ~ 5.825GHz，一共划分了 32 个信道，每个信道带宽有 10 MHz、20 MHz、40 MHz、80 MHz 和 160 MHz 不等，有 22 个互不干扰的信道。&lt;/p&gt;

&lt;h3 id=&quot;2-调制方式&quot;&gt;2. 调制方式&lt;/h3&gt;

&lt;p&gt;802.11 常用调制方式有 DSSS 和 OFDM。&lt;/p&gt;

&lt;p&gt;DSSS（直接序列展频）是利用 10 个以上的 chip 来表示原来的 0 和 1，使原本高频率、窄频的信号转换为低功率的宽频信号，完成扩频，接收方再以同样的规则解扩，从各 chip 中恢复原信号。&lt;/p&gt;

&lt;p&gt;OFDM（正交频分复用）将一整段频段分割成数个子载波，而且让每个子载波相互正交，使得他们在频谱上并不互相重叠，可以降低干扰，传输端将信号摆置在频域上，透过反傅里叶转换转换至时域，增加循环前缀后传送出去，接收端去除信号循环前缀，再将时域信号转换回频域，解出原信号。&lt;/p&gt;

&lt;h3 id=&quot;3-mimo&quot;&gt;3. MIMO&lt;/h3&gt;

&lt;p&gt;SISO 和 MIMO 是 WLAN 天线发送和接收信号的两种方式。SISO (Single Input Single Output) 即单输入单输出，顾名思义是通信时一根发射天线对应一根接收天线；MIMO (Multiple Input Multiple Output) 即多输入多输出，表示多根发射天线和多跟接收天线的通信；除此之外还有 SIMO 和 MISO 等。早期的 802.11 采用 SISO，传输速率较慢，MIMO 通过增加天线数量大幅提高传输速率。&lt;/p&gt;

&lt;p&gt;MIMO 传输如下图，假设有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt; 根发射天线，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; 根接收天线，那么可以得到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m × n&lt;/code&gt; 的传输矩阵，即可以产生 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m × n&lt;/code&gt; 个信道。理论上信道容量和天线数量成正比。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/Structure-of-multiple-input-multiple-output-MIMO-systems-with-N-transmit-TX-and-L.webp&quot; alt=&quot;MIMO 示意图&quot; /&gt;
  &lt;figcaption&gt;
      MIMO 传输示意

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;MIMO 工作时，发射端将高速率的数据流拆分为几个低速率的子数据流，这些子数据流在不同天线上以相同频段发射，接收端将同时来自多根天线的信号以一定方式复原为原数据流。发射端使用多根天线平行发射子数据流，这种方式被称为空分复用，可以成倍提高信道容量；同时接收端多根天线接收到相同的信号，这被称为空间分集，提升信道的可靠性。此外MIMO还有波束成形、预编码等技术，它们并不互斥，可以互相配合应用。&lt;/p&gt;

&lt;p&gt;802.11ac Wave 2 引入了 MU-MIMO，即多用户多输出多输入，与单用户不同的是，发射端可以同时与多个接收端通信，各接收端互不干扰。&lt;/p&gt;

&lt;h2 id=&quot;三wlan-网络的组织方式&quot;&gt;三、WLAN 网络的组织方式&lt;sup id=&quot;fnref:1:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;

&lt;h3 id=&quot;1-wlan-网络组成&quot;&gt;1. WLAN 网络组成&lt;/h3&gt;

&lt;p&gt;一个 WLAN 网络中，有工作站（STA）、接入点（AP）、基本服务集（BSS）、扩展服务集（ESS）、骨干网络等成员。如下图：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-ess.webp&quot; alt=&quot;ESS 示意图&quot; /&gt;
  &lt;figcaption&gt;
      WLAN 组网示意

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;AP 是 WLAN 存在的基础，STA 通过与 AP 关联加入 WLAN。BSS 是 802.11 网络组网的基本单元，一个 BSS 对应于一个 AP，它的服务范围也就是 AP 的信号覆盖范围。一个 AP 的信号覆盖范围有限，802.11 允许将多个 BSS 串联为一个 ESS，隶属于同一个 ESS 的 STA 可以相互通信。ESS 中各 BSS 连接至同一个骨干网络，为了在 ESS 中实现跨 BSS 通信，相应的 AP 之间要能够在骨干网络中建立 OSI 第二层的连接，骨干网络通常是以太网。&lt;/p&gt;

&lt;p&gt;在安全方面，802.11i 提供了 WLAN 安全机制，使用 802.11i 所定义和改良的身份验证协议和机密性协议的网络，被称为 RSN（Robust Security Network），其中的连接则为RSNA（RSN Associations）。&lt;/p&gt;

&lt;h3 id=&quot;2-wlan-网络类型&quot;&gt;2. WLAN 网络类型&lt;/h3&gt;

&lt;p&gt;BSS 根据组网结构不同分为两类，一类是集中于 AP 的基础结构型网络（BSS），一种是无 AP 的独立型网络（IBSS）。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/80211-bss-type.webp&quot; alt=&quot;BSS 类型图&quot; /&gt;
  &lt;figcaption&gt;
      独立型与基础结构型网络的基本服务集

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;基础结构性网络（Infrastructure BSS）是有 AP 参与的无线网络。AP 是基础结构型网络的关键，它向外界周期性地广播 Beacon 帧，宣告网络的存在，STA 在连入基础结构型网络时，必须先与 AP 建立关联。AP 负责处理网络中所有通信，STA1 与 STA2 通信时，发往 STA2 的数据必须从 STA1 发至 AP，然后由 AP 转发至 STA2。基础结构型网络服务集被界定在 AP 的传输范围之内。&lt;/p&gt;

&lt;p&gt;独立型网络（Independent BSS，简称 IBSS）是没有 AP 参与的无线网络。在 IBSS 中，STA 之间可以直接通信。IBSS 由两个或更多的 STA 组成，服务集覆盖范围不固定，由各 STA 轮流广播 Beacon 帧来宣告网络的存在。&lt;/p&gt;

&lt;h3 id=&quot;3-wlan-网络的运作方式&quot;&gt;3. WLAN 网络的运作方式&lt;/h3&gt;

&lt;p&gt;与以太网相比，WLAN 为设备提供了可移动性，为了让网络能够正确追踪移动节点及帧传递，802.11 定义了 9 种服务，见下表，其中前 3 种用来传送数据，其余 6 种均属管理操作。&lt;/p&gt;

&lt;div class=&quot;table-wrapper&quot;&gt;
  &lt;table&gt;&lt;caption&gt;
        WLAN 服务

    &lt;/caption&gt;

  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;服务&lt;/th&gt;
      &lt;th&gt;用途&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;分布式&lt;/td&gt;
      &lt;td&gt;传递帧时，可使用此服务来决定目的地在网络上的地址&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;整合&lt;/td&gt;
      &lt;td&gt;用来将帧传递至无线网络以外的 IEEE 802 LAN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MSDU 传送&lt;/td&gt;
      &lt;td&gt;用来传递数据至接收端&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;关联&lt;/td&gt;
      &lt;td&gt;用来建立 AP（作为网关使用）于特定移动式工作站间的关联&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;重新关联&lt;/td&gt;
      &lt;td&gt;用来变更 AP（作为网关使用）于特定移动式工作站间的关联&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;取消关联&lt;/td&gt;
      &lt;td&gt;用来从网络移除无线工作站&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;身份验证&lt;/td&gt;
      &lt;td&gt;建立关联之前用来进行身份验证（利用 MAC 地址）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;解除身份验证&lt;/td&gt;
      &lt;td&gt;用来终结一段身份验证关系，其副作用是终止当前关联&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;机密性&lt;/td&gt;
      &lt;td&gt;用来防止窃听&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;传输功率控制（TPC）&lt;/td&gt;
      &lt;td&gt;频谱管理，降低工作站传输功率以减少干扰&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;动态频率选择（DFS）&lt;/td&gt;
      &lt;td&gt;频谱管理，避免在 5 GHz 频段干扰雷达操作&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;/div&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Gast, M. S. 802.11® 无线网络权威指南[M]. 第 2 版. O’Reilly Taiwan 公司. 南京 - 东南大学出版社, 2007.12: 24-37 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:1:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Lnki</name></author><category term="技术" /><category term="网络" /><category term="WLAN" /><summary type="html">关于无线网络，我们常提到 WLAN、Wi-Fi、IEEE 802.11 a/b/g/n/ac 等名词，它们似乎都可以指无线网络，这里先了解它们的概念和区别：</summary></entry><entry><title type="html">计算机网络模型</title><link href="https://www.lnki.me/2018/09/network-model/" rel="alternate" type="text/html" title="计算机网络模型" /><published>2018-09-08T00:00:00+08:00</published><updated>2018-09-08T00:00:00+08:00</updated><id>https://www.lnki.me/2018/09/network-model</id><content type="html" xml:base="https://www.lnki.me/2018/09/network-model/">&lt;h2 id=&quot;一osi-七层模型&quot;&gt;一、OSI 七层模型&lt;/h2&gt;

&lt;p&gt;OSI（Open System Interconnection）模型是一种计算机网络标准框架，是一种全球各种计算平台和网络之间数据通信的完整解决方案。OSI 是理论上的网络标准，而实际上的工业标准是 TCP/IP 协议族，理解 OSI 有助于理解 TCP/IP。&lt;/p&gt;

&lt;p&gt;OSI 是一种分组网络模型，定义了七层网络模型，每层的功能相互独立，通过定义一些协议来描述处理过程，这样的好处是上层的修改不影响下层的结构。OSI分层模型的核心思想是封装，上层的数据包对于下层协议而言就是一个黑箱，下层协议只处理本层信息，不关心上层数据包的内容。在通信过程中，下层协议对于上层协议是透明的，下层协议通过封装、编码、加密等方式承载上层协议的数据包。&lt;/p&gt;

&lt;p&gt;发送时，信息从应用层开始向下逐层封装，最终物理层将信息转化成信号传播到介质中；接收时，首先物理层从介质传来的信号中获取信息，再向上逐层拆包，最终到达应用层。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/osi-model.webp&quot; alt=&quot;OSI 网络模型封装过程示意图&quot; /&gt;
  &lt;figcaption&gt;
      OSI 模型结构及数据封装

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;h3 id=&quot;1-物理层&quot;&gt;1. 物理层&lt;/h3&gt;

&lt;p&gt;物理层的处理单元是 bit（比特），负责将信息编码成电流脉冲、电磁波等形式的信号并传播出去，同时从信号中解码信息生成原始 bit 码。它定义了 bit 和信号之间的转换方式，以及物理介质的光电、电气和机械特性。&lt;/p&gt;

&lt;h3 id=&quot;2-数据链路层&quot;&gt;2. 数据链路层&lt;/h3&gt;

&lt;p&gt;数据链路层的处理单元是帧（Frame），负责构建物理设备的逻辑链路，并将输入的数据转换为数据帧，同时负责检测和修正传输出现的错误。工作在该层的设备主要是交换机。&lt;/p&gt;

&lt;p&gt;该层又被划分为两个子层，分别为介质访问控制（MAC）子层和逻辑链路控制（LLC）子层。&lt;/p&gt;

&lt;p&gt;MAC 子层的主要功能包括数据帧的封装/卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。MAC 子层的存在屏蔽了不同物理链路种类的差异性，解决了局域网共用信道出现冲突时的介质使用权分配。在传统局域网中，普遍使用的 MAC 标准是 IEEE 802.3，即通常所说的以太网（Ethernet），采用 CSMA/CD 的方式避免冲突；在无线网络中，MAC 标准为 IEEE 802.11。MAC 子层还采用多种方式提高传输效率，包括 TDM、FDM、WDM 和 CDMA。&lt;/p&gt;

&lt;p&gt;LLC 子层向上层提供服务，包括传输可靠性保障和控制、数据包的分段与重组、数据包的顺序传输等，IEEE 802.2 定义了它的功能和服务，它提供了访问各种介质的方法。LLC 负责识别网络层协议，然后对它们进行封装。LLC 报头告诉数据链路层当帧被接收到时，应当对数据包做何处理。&lt;/p&gt;

&lt;h3 id=&quot;3-网络层&quot;&gt;3. 网络层&lt;/h3&gt;

&lt;p&gt;网络层的处理单元是包（Packet），提供点到点的数据传输服务，该层协议描述了在设备之间如何传输数据，即描述了如何确定数据包从发送方到接收方的路径，它依据独一的地址信息来为数据包提供路由；与此同时负责流量和拥塞控制，以防止网络资源耗尽。工作在该层的设备有路由器、防火墙等。&lt;/p&gt;

&lt;p&gt;IP 是网络层的核心协议，负责将数据包从源地址发送到目的地址，它提供不可靠的传输服务，并由一些辅助协议提供拓展功能。ICMP 负责差错控制，IGMP 负责建立和维护组播成员关系，两者数据承载在 IP 数据包之上；ARP 负责根据 IP 地址解析当前网络的物理地址，RARP 则根据物理地址解析 IP 地址，两者数据直接承载在帧上。IP 实现了不同网络之间的通信，每个网络的边界称为网关，IP 还提供了子网划分和子网融合，提供灵活的网络管理功能。&lt;/p&gt;

&lt;p&gt;网络层另一重要功能是路由，常见的路由协议由 RIP、OSPF 等等，这些协议负责建立和维护路由表，在转发 IP 数据包时，将目的地址和路由表逐条比对，然后从匹配的端口转发。&lt;/p&gt;

&lt;h3 id=&quot;4-传输层&quot;&gt;4. 传输层&lt;/h3&gt;

&lt;p&gt;传输层的处理单元是消息（Message），负责管理网络中端到端的消息传输，通过错误恢复和流量控制的机制为数据包传输提供可靠性和顺序性，同时提供了一种面向连接的数据包传输方式。&lt;/p&gt;

&lt;p&gt;传输层最主要的两个协议是 TCP 和 UDP，提供端口到端口、进程到进程的数据传输服务。TCP 是面向连接的，提供的是可靠服务，因此没有广播功能，它通过三次握手、ACK 应答、重传等机制进行差错控制，以及通过慢启动、快速重传、滑动窗口等机制进行流量控制；UDP 提供不可靠服务，能进行广播和组播，它没有差错控制和流量控制机制，数据包结构简单，封装快速，适用于需要快速响应或流量较大的应用。&lt;/p&gt;

&lt;h3 id=&quot;5-会话层&quot;&gt;5. 会话层&lt;/h3&gt;

&lt;p&gt;会话层使不同设备上的用户之间能够建立会话，它负责控制用户间逻辑链路的建立和终止，同时负责报告上层的错误。常见的协议有 SSL/TLS 和 RPC 等。&lt;/p&gt;

&lt;h3 id=&quot;6-表示层&quot;&gt;6. 表示层&lt;/h3&gt;

&lt;p&gt;表示层标记不同系统之间的数据差异，并指定独立于系统架构的数据传输格式，它负责编码解码、加密解密和压缩解压数据。&lt;/p&gt;

&lt;h3 id=&quot;7-应用层&quot;&gt;7. 应用层&lt;/h3&gt;

&lt;p&gt;应用层包含用户使用的各种服务和协议，例如文件传输、电子邮件、Web 等等。&lt;/p&gt;

&lt;h2 id=&quot;二tcpip-四层模型&quot;&gt;二、TCP/IP 四层模型&lt;/h2&gt;

&lt;p&gt;尽管 OSI 定义很完善，但存在一些问题，首先实现复杂度较高，其次各层的功能划分不均，例如表示层和会话层的功能相对较少，因此相对简单的 TCP/IP 协议族是实际上的工业标准。TCP/IP 层级模型类似 OSI，但是没有公认的标准，通常采用四层模型来描述，相比于 OSI，TCP/IP 四层模型取消了会话层和表示层，同时把物理层和数据链路层融合为一个网络接口层。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/osi-tcp-ip.webp&quot; alt=&quot;TCP/IP 模型图&quot; /&gt;
  &lt;figcaption&gt;
      OSI 与 TCP/IP 模型

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;h3 id=&quot;1-网络接口层&quot;&gt;1. 网络接口层&lt;/h3&gt;

&lt;p&gt;网络接口层规定主机必须使用某种协议连接到网络，以便向该主机发送 IP 数据包；这里所提到的协议并没有明确定义，可能在不同主机和网络上有不同的定义和实现。&lt;/p&gt;

&lt;h3 id=&quot;2-网络层&quot;&gt;2. 网络层&lt;/h3&gt;

&lt;p&gt;这里的网络层功能上和 OSI 网络层类似，它定义了正式的 IP 协议，规定了网络间传输的数据包格式和协议，IP 是 TCP/IP 协议族中最重要的协议，主要功能是将数据包发送到指定的目的地。&lt;/p&gt;

&lt;h3 id=&quot;3-传输层&quot;&gt;3. 传输层&lt;/h3&gt;

&lt;p&gt;传输层同样功能上类似于OSI传输层，主要包含两个端到端协议：TCP 和 UDP，它们也是 TCP/IP 中的重要协议，用于不同系统之间的跨进程通信。&lt;/p&gt;

&lt;h3 id=&quot;4-应用层&quot;&gt;4. 应用层&lt;/h3&gt;

&lt;p&gt;与OSI不同的是，应用层之下不再包括表示层和会话层，功能上和OSI应用层相似，提供高层的协议，例如 SMTP、FTP 等等。&lt;/p&gt;

&lt;h2 id=&quot;三五层模型&quot;&gt;三、五层模型&lt;/h2&gt;

&lt;p&gt;上述的 TCP/IP 模型没有很好地描述物理层和数据链路层的功能，而 OSI 模型的会话层和表示层几乎闲置，综合两者的特点，提出一种五层模型来描述网络分层结构，它类似于 TCP/IP 四层模型，只是将网络接口层替换为 OSI 七层模型的物理层和数据链路层，包括物理层、数据链路层、网络层、传输层和应用层。&lt;/p&gt;

&lt;p&gt;五层模型仅用于学习和理解计算机网络原理，实际网络工程中并不常见。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/osi-5-leyer-arch.webp&quot; alt=&quot;五层模型图&quot; /&gt;
  &lt;figcaption&gt;
      五层模型与 OSI

    &lt;/figcaption&gt;&lt;/figure&gt;</content><author><name>Lnki</name></author><category term="技术" /><category term="网络" /><summary type="html">一、OSI 七层模型</summary></entry><entry><title type="html">Android 系统架构</title><link href="https://www.lnki.me/2018/09/android-arch/" rel="alternate" type="text/html" title="Android 系统架构" /><published>2018-09-05T00:00:00+08:00</published><updated>2018-09-05T00:00:00+08:00</updated><id>https://www.lnki.me/2018/09/android-arch</id><content type="html" xml:base="https://www.lnki.me/2018/09/android-arch/">&lt;p class=&quot;notice&quot;&gt;本文所述 Android 架构，是指 Android 系统内部的体系&lt;a href=&quot;https://source.android.com/devices/architecture&quot; title=&quot;Android 架构&quot;&gt;架构&lt;/a&gt;，相对于应用开发角度的 Android &lt;a href=&quot;https://developer.android.com/guide/platform&quot; title=&quot;平台架构&quot;&gt;平台架构&lt;/a&gt;，更偏重展现 Android 系统内部的调用机制，用于指导 Android 硬件开发和系统开发。&lt;/p&gt;

&lt;h2 id=&quot;一架构&quot;&gt;一、架构&lt;/h2&gt;

&lt;p&gt;先看看来自官方的架构图：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/ape_fwk_all.webp&quot; alt=&quot;Android 架构图&quot; /&gt;
  &lt;figcaption&gt;
      Android 架构

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;可以看到，Android 系统分为五层，自上而下依次为：&lt;/p&gt;

&lt;h3 id=&quot;1-应用框架层&quot;&gt;1. 应用框架层&lt;/h3&gt;

&lt;p&gt;应用框架层中的 API 主要用于应用开发，而从系统开发角度，这些 API 都是底层 HAL 接口的映射，可以理解为 Android 系统和应用之间的边界。&lt;/p&gt;

&lt;h3 id=&quot;2-binder-ipc-层&quot;&gt;2. Binder IPC 层&lt;/h3&gt;

&lt;p&gt;Binder Inter-Process Communication（IPC），基于 Binder 的进程间通信机制，允许应用框架层跨越进程边界并调用 Android 系统服务层代码，实现框架 API 与 Android 系统服务之间的交互。这些通信过程对于应用开发者是透明的。&lt;/p&gt;

&lt;h3 id=&quot;3-系统服务层&quot;&gt;3. 系统服务层&lt;/h3&gt;

&lt;p&gt;系统服务是负责不同功能的模块化组件，例如窗口管理器、通知管理器、WLAN 管理器等等，应用框架 API 通过与系统服务通信来访问系统功能和底层硬件。Android 包含两组服务：“系统”（比如窗口管理器、通知管理器等服务）和“媒体”（与播放、录制媒体相关的服务）。&lt;/p&gt;

&lt;h3 id=&quot;4-硬件抽象层hal&quot;&gt;4. 硬件抽象层（HAL）&lt;/h3&gt;

&lt;p&gt;Hardware Abstraction Layer（HAL），硬件抽象层，定义标准接口供硬件开发者实现，硬件开发者可以通过这些接口方便地实现特定功能，而不用担心对系统上层造成影响，系统服务则可以通过访问硬件抽象层，忽略更低级别的驱动实现。除了标准接口，Android 也允许系统开发者自定义 HAL 接口，便于实现定制功能。HAL 的实现会被封装成模块，通常编译为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so&lt;/code&gt; 文件，并由 Android 系统适时加载。&lt;/p&gt;

&lt;p&gt;从 Android 8.0 开始，引入了 HIDL，HAL 的运行方式也分为了两种：绑定式和直通式，Android 框架和系统服务通过 Binder IPC 机制与绑定式 HAL 通信，直通式则是在系统服务的同一进程下直接调用 HAL。绝大多数 HAL 是绑定式。&lt;/p&gt;

&lt;h3 id=&quot;5-linux-内核层&quot;&gt;5. Linux 内核层&lt;/h3&gt;

&lt;p&gt;开发设备驱动程序类似于开发典型的 Linux 设备驱动程序。除了驱动程序，Android 使用的 Linux 内核还包含一些特殊的补充功能，例如低内存终止、唤醒锁定、Binder IPC 驱动等等，以及对移动嵌入式平台来说非常重要的其他功能，如 wpa_supplicant、netd 等等。这些补充功能主要用于增强系统功能，不会影响驱动程序开发。&lt;/p&gt;

&lt;h2 id=&quot;二运行机制&quot;&gt;二、运行机制&lt;/h2&gt;

&lt;p&gt;上面静态地展示了 Android 的系统架构，只是抽象地了解了其大体结构和所扮演的角色。为更具体地理解 Android 运行机制，下面以 &lt;a href=&quot;https://source.android.com/devices/audio&quot;&gt;Audio 模块&lt;/a&gt;为例，动态地看一看 Android 运行时的调用过程：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/ape_fwk_audio.webp&quot; alt=&quot;Android Audio 架构图&quot; /&gt;
  &lt;figcaption&gt;
      Android Audio 架构

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;当某个应用访问 Audio 模块时，自上而下的调用过程如下：&lt;/p&gt;

&lt;h3 id=&quot;1-应用框架&quot;&gt;1. 应用框架&lt;/h3&gt;

&lt;p&gt;应用框架包含应用的代码，该代码可使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;android.media&lt;/code&gt; API 与 Audio 硬件进行交互。在内部，此代码会调用相应的 JNI 粘合类，以访问与 Audio 硬件交互的 native 代码。应用可以直接调用的框架代码位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frameworks/base/media/java&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2-jni&quot;&gt;2. JNI&lt;/h3&gt;

&lt;p&gt;与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;android.media&lt;/code&gt; 关联的 JNI 代码可调用较低级别的原生代码，以访问 Audio 硬件。JNI 代码位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frameworks/base/core/jni&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frameworks/base/media/jni&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;3-native-框架&quot;&gt;3. Native 框架&lt;/h3&gt;

&lt;p&gt;Native 框架提供相当于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;android.media&lt;/code&gt; 包的 native 代码包，调用 Binder IPC 代理以访问 Media 服务器的特定于音频的服务。原生框架代码位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frameworks/av/media/libmedia&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;4-binder-ipc&quot;&gt;4. Binder IPC&lt;/h3&gt;

&lt;p&gt;Binder IPC 代理用于促进跨越进程边界的通信。代理代码位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frameworks/av/media/libmedia&lt;/code&gt;，文件以字母“I”开头。&lt;/p&gt;

&lt;h3 id=&quot;5-media-服务&quot;&gt;5. Media 服务&lt;/h3&gt;

&lt;p&gt;Media 服务包含 Audio 服务，这些 Audio 服务是实际与 HAL 实现进行交互的代码。Media 服务位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frameworks/av/services/audioflinger&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;6-hal&quot;&gt;6. HAL&lt;/h3&gt;

&lt;p&gt;HAL 定义了由 Audio 服务调用的标准接口，必须正确实现这些接口以确保 Audio 硬件功能正常运行。Audio HAL 接口位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hardware/libhardware/include/hardware&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;7-内核驱动程序&quot;&gt;7. 内核驱动程序&lt;/h3&gt;

&lt;p&gt;Audio 驱动程序分别与硬件和 HAL 实现进行交互，最终完成从应用对 Audio 硬件的访问。可以使用高级 Linux 音频架构（ALSA）、开放声音系统（OSS）或自定义驱动程序（HAL 与驱动程序无关）。&lt;/p&gt;

&lt;h2 id=&quot;三总结&quot;&gt;三、总结&lt;/h2&gt;

&lt;p&gt;经过对 Android 系统内部架构的梳理，可以看到，这种架构就类似于网络中常见的 C/S 架构，系统服务是服务器，应用程序是客户端，Binder IPC 机制则是承载两者交互的网络，Android 把每个系统功能拆分成不同的系统服务，它们管理相应的系统资源，通过 Binder IPC 机制，使每个应用有条不紊地向系统服务请求资源。&lt;/p&gt;</content><author><name>Lnki</name></author><category term="技术" /><category term="Android" /><summary type="html">本文所述 Android 架构，是指 Android 系统内部的体系架构，相对于应用开发角度的 Android 平台架构，更偏重展现 Android 系统内部的调用机制，用于指导 Android 硬件开发和系统开发。</summary></entry></feed>