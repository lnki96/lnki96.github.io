<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://www.lnki.me/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.lnki.me/" rel="alternate" type="text/html" /><updated>2021-02-20T19:48:51+08:00</updated><id>https://www.lnki.me/feed.xml</id><title type="html">Lnki’s Home · 网上冲浪日志</title><subtitle>这里是 Lnki 的小站，我在这里分享知识、记录日常。</subtitle><author><name>Lnki</name></author><entry><title type="html">Android 系统架构</title><link href="https://www.lnki.me/2018/09/android-arch/" rel="alternate" type="text/html" title="Android 系统架构" /><published>2018-09-05T00:00:00+08:00</published><updated>2018-09-05T00:00:00+08:00</updated><id>https://www.lnki.me/2018/09/android-arch</id><content type="html" xml:base="https://www.lnki.me/2018/09/android-arch/">&lt;p class=&quot;notice&quot;&gt;本文所述 Android 架构，是指 Android 系统内部的体系&lt;a href=&quot;https://source.android.com/devices/architecture&quot; title=&quot;Android 架构&quot;&gt;架构&lt;/a&gt;，相对于应用开发角度的 Android &lt;a href=&quot;https://developer.android.com/guide/platform&quot; title=&quot;平台架构&quot;&gt;平台架构&lt;/a&gt;，更偏重展现 Android 系统内部的调用机制，用于指导 Android 硬件开发和系统开发。&lt;/p&gt;

&lt;h2 id=&quot;一架构&quot;&gt;一、架构&lt;/h2&gt;

&lt;p&gt;先看看来自官方的架构图：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/ape_fwk_all.webp&quot; alt=&quot;Android 架构图&quot; /&gt;
  &lt;figcaption&gt;
      Android 架构

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;可以看到，Android 系统分为五层，自上而下依次为：&lt;/p&gt;

&lt;h3 id=&quot;1-应用框架层&quot;&gt;1. 应用框架层&lt;/h3&gt;

&lt;p&gt;应用框架层中的 API 主要用于应用开发，而从系统开发角度，这些 API 都是底层 HAL 接口的映射，可以理解为 Android 系统和应用之间的边界。&lt;/p&gt;

&lt;h3 id=&quot;2-binder-ipc-层&quot;&gt;2. Binder IPC 层&lt;/h3&gt;

&lt;p&gt;Binder Inter-Process Communication（IPC），基于 Binder 的进程间通信机制，允许应用框架层跨越进程边界并调用 Android 系统服务层代码，实现框架 API 与 Android 系统服务之间的交互。这些通信过程对于应用开发者是透明的。&lt;/p&gt;

&lt;h3 id=&quot;3-系统服务层&quot;&gt;3. 系统服务层&lt;/h3&gt;

&lt;p&gt;系统服务是负责不同功能的模块化组件，例如窗口管理器、通知管理器、WLAN 管理器等等，应用框架 API 通过与系统服务通信来访问系统功能和底层硬件。Android 包含两组服务：“系统”（比如窗口管理器、通知管理器等服务）和“媒体”（与播放、录制媒体相关的服务）。&lt;/p&gt;

&lt;h3 id=&quot;4-硬件抽象层hal&quot;&gt;4. 硬件抽象层（HAL）&lt;/h3&gt;

&lt;p&gt;Hardware Abstraction Layer（HAL），硬件抽象层，定义标准接口供硬件开发者实现，硬件开发者可以通过这些接口方便地实现特定功能，而不用担心对系统上层造成影响，系统服务则可以通过访问硬件抽象层，忽略更低级别的驱动实现。除了标准接口，Android 也允许系统开发者自定义 HAL 接口，便于实现定制功能。HAL 的实现会被封装成模块，通常编译为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so&lt;/code&gt; 文件，并由 Android 系统适时加载。&lt;/p&gt;

&lt;p&gt;从 Android 8.0 开始，引入了 HIDL，HAL 的运行方式也分为了两种：绑定式和直通式，Android 框架和系统服务通过 Binder IPC 机制与绑定式 HAL 通信，直通式则是在系统服务的同一进程下直接调用 HAL。绝大多数 HAL 是绑定式。&lt;/p&gt;

&lt;h3 id=&quot;5-linux-内核层&quot;&gt;5. Linux 内核层&lt;/h3&gt;

&lt;p&gt;开发设备驱动程序类似于开发典型的 Linux 设备驱动程序。除了驱动程序，Android 使用的 Linux 内核还包含一些特殊的补充功能，例如低内存终止、唤醒锁定、Binder IPC 驱动等等，以及对移动嵌入式平台来说非常重要的其他功能，如 wpa_supplicant、netd 等等。这些补充功能主要用于增强系统功能，不会影响驱动程序开发。&lt;/p&gt;

&lt;h2 id=&quot;二运行机制&quot;&gt;二、运行机制&lt;/h2&gt;

&lt;p&gt;上面静态地展示了 Android 的系统架构，只是抽象地了解了其大体结构和所扮演的角色。为更具体地理解 Android 运行机制，下面以 &lt;a href=&quot;https://source.android.com/devices/audio&quot;&gt;Audio 模块&lt;/a&gt;为例，动态地看一看 Android 运行时的调用过程：&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  
  &lt;img src=&quot;/contents/posts/ape_fwk_audio.webp&quot; alt=&quot;Android Audio 架构图&quot; /&gt;
  &lt;figcaption&gt;
      Android Audio 架构

    &lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;当某个应用访问 Audio 模块时，自上而下的调用过程如下：&lt;/p&gt;

&lt;h3 id=&quot;1-应用框架&quot;&gt;1. 应用框架&lt;/h3&gt;

&lt;p&gt;应用框架包含应用的代码，该代码可使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;android.media&lt;/code&gt; API 与 Audio 硬件进行交互。在内部，此代码会调用相应的 JNI 粘合类，以访问与 Audio 硬件交互的 native 代码。应用可以直接调用的框架代码位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frameworks/base/media/java&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2-jni&quot;&gt;2. JNI&lt;/h3&gt;

&lt;p&gt;与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;android.media&lt;/code&gt; 关联的 JNI 代码可调用较低级别的原生代码，以访问 Audio 硬件。JNI 代码位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frameworks/base/core/jni&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frameworks/base/media/jni&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;3-native-框架&quot;&gt;3. Native 框架&lt;/h3&gt;

&lt;p&gt;Native 框架提供相当于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;android.media&lt;/code&gt; 包的 native 代码包，调用 Binder IPC 代理以访问 Media 服务器的特定于音频的服务。原生框架代码位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frameworks/av/media/libmedia&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;4-binder-ipc&quot;&gt;4. Binder IPC&lt;/h3&gt;

&lt;p&gt;Binder IPC 代理用于促进跨越进程边界的通信。代理代码位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frameworks/av/media/libmedia&lt;/code&gt;，文件以字母“I”开头。&lt;/p&gt;

&lt;h3 id=&quot;5-media-服务&quot;&gt;5. Media 服务&lt;/h3&gt;

&lt;p&gt;Media 服务包含 Audio 服务，这些 Audio 服务是实际与 HAL 实现进行交互的代码。Media 服务位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frameworks/av/services/audioflinger&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;6-hal&quot;&gt;6. HAL&lt;/h3&gt;

&lt;p&gt;HAL 定义了由 Audio 服务调用的标准接口，必须正确实现这些接口以确保 Audio 硬件功能正常运行。Audio HAL 接口位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hardware/libhardware/include/hardware&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;7-内核驱动程序&quot;&gt;7. 内核驱动程序&lt;/h3&gt;

&lt;p&gt;Audio 驱动程序分别与硬件和 HAL 实现进行交互，最终完成从应用对 Audio 硬件的访问。可以使用高级 Linux 音频架构（ALSA）、开放声音系统（OSS）或自定义驱动程序（HAL 与驱动程序无关）。&lt;/p&gt;

&lt;h2 id=&quot;三总结&quot;&gt;三、总结&lt;/h2&gt;

&lt;p&gt;经过对 Android 系统内部架构的梳理，可以看到，这种架构就类似于网络中常见的 C/S 架构，系统服务是服务器，应用程序是客户端，Binder IPC 机制则是承载两者交互的网络，Android 把每个系统功能拆分成不同的系统服务，它们管理相应的系统资源，通过 Binder IPC 机制，使每个应用有条不紊地向系统服务请求资源。&lt;/p&gt;</content><author><name>Lnki</name></author><category term="技术" /><category term="Android" /><summary type="html">本文所述 Android 架构，是指 Android 系统内部的体系架构，相对于应用开发角度的 Android 平台架构，更偏重展现 Android 系统内部的调用机制，用于指导 Android 硬件开发和系统开发。</summary></entry></feed>